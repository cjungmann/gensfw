#!/bin/bash

# Primary Dialogs in this application (many dialogs have sub-dialogs):
# 1: Select Database from List (or open GSF file)
# 2: Select Table from List (or open GSF file)
# 3: Edit Table Preferences Dialog, can start dialogs 4, 5, and 6
# 4: Edit Interaction Preferences Dialog
# 5: Set Default Column Labels
# 6: Save Files Dialog

# Universal script indentation string, must precede 'source' calls that use it:
declare gsf_script_indent="  "
indent_line() { echo "${gsf_script_indent}${1}"; }

get_source_path()
{
    # Must include both the colon AND the space to trim
    # the spaces from the path in the array:
    local IFS=": "
    local -a arr=( $( whereis gensfw ) )
    zpath=$( readlink "${arr[1]}" )
    zpath="${zpath%%gensfw}"
}

get_source_path

source "${zpath}gensfw_bacts"
source "${zpath}gensfw_scripts_sql"
source "${zpath}gensfw_scripts_srm"

# One or the other of the following, either override
# default SEPS (first line), or get the default SEPS
# values from bashmysql:
SEPS='%^&'
# SEPS=$( bashmysql -S )

RSEP="${SEPS:0:1}"
FSEP="${SEPS:1:1}"
VSEP="${SEPS:2:1}"

YSEP="${VSEP}"
# YSEP='^'

# Global variable also serves as a flag to prevent collect_table_info()
# from attempting to call lthe follow-on function
declare CL_CMD

declare -a IACT_NAMES=( List Add Read Update Delete Import Export )
declare -a IACT_COLUMNS=( Type Param Result Readonly Hide Label )

declare -gi G_PLUG_NUM=$$ ## Commence plug numbers from process id

# COL_xxxx integers are indexes to column for result of COLS_QUERY
# These will not change once set
declare -gi COL_NAME
declare -gi COL_TYPE
declare -gi COL_COLTYPE
declare -gi COL_AUTOINC
declare -gi COL_PRIKEY
declare -gi COL_PRECISION
declare -gi COL_SCALE
declare -gi COL_MAXLEN
declare -gi COL_DEFAULT
declare -gi COL_FORKEY

# The list of available database won't change (unless we change hosts):
declare -a DBASE_NAMES=( $( mysql -BN -e "show databases" ) ) 

# The next two variables can be either set from command line,
# from dialogs 1 and 2, or by opening a settings file:
declare -gx GF_DBNAME
declare -gx GF_TNAME

declare -gx GF_PROC_ROOT

# 
declare -gx GF_FILE_ARG
declare -gx GF_FILEPATH_GSF
declare -gx GF_FILEPATH_SQL
declare -gx GF_FILEPATH_SRM

# This array changes when GF_DBNAME changes (from Dialog 1):
declare -a TABLE_NAMES

declare -a GSF_FIELD_NAMES  # Initialized when a table is selected
declare -a GSF_FIELD_LABELS # From settings file or by using Dialog 5 (default labels)
declare -a GSF_FIELD_SLINKS # String settings to link session variables to fields
declare -a GSF_SRM_GLOBALS  # Value pairs to be added to the top of the SRM file

declare -a IACT_FIELD_LABELS
declare -A IACT_DATA

# Clear variables that might retain info from previous table:
reset_for_new_table()
{
    GF_FILEPATH_GSF=
    GF_FILEPATH_SQL=
    GF_FILEPATH_SRM=
    GSF_FIELD_NAMES=()
    GSF_FIELD_LABELS=()
    GSF_FIELD_SLINKS=()
    GSF_SRM_GLOBALS=()
}

set_file_path_defaults()
{
    local IFS="/"
    local lpath fname froot
    local -a tarr farr=( $( echo "$1" ) )
    local -i tlen flen="${#farr[@]}"
    if [ $flen -eq 1 ]; then
        fname="$1"
        lpath=""
    else
        tarr=( "${farr[@]:0:$(( flen-1 ))}" )
        lpath="${tarr[*]}"
        fname="${farr[ $(( flen-1 )) ]}"
    fi


    IFS="\."
    tarr=( $( echo "${fname}" ) )
    tlen="${#tarr[@]}"
    if [ $tlen -eq 0 ]; then
        froot="${fname}"
    else
        froot="${tarr[*]:0:$(( tlen-1 ))}"
    fi
    froot="${tarr[@]:0:$(( tlen-1 ))}"

    local fbase="${froot}"
    if [ -n "${lpath}" ]; then
        fbase="${lpath}/${froot}"
    fi
    GF_FILEPATH_GSF="$1"
    GF_FILEPATH_SQL="${fbase}.sql"
    GF_FILEPATH_SRM="${fbase}.srm"
}

# Convenient function to avoid having to know the array name:
get_fields_count() { echo "${#GSF_FIELD_NAMES[@]}"; }

# All primary yad dialogs should use this
# (Not paned or notebook plugs):
declare -a YAD_COMMON_ARGS=(
    --height 500
    --width 750
    --center
    --borders 10
    --separator "${YSEP}"
    --title "Generate Schema Framework Scripts"
)


### Dialog #3: Table Preferences Dialog ###
### Usde in function: show_table_preferences_dialog()
# Primary yad dialog, for current dbase/table
# - Select interaction types to edit
# - Set default column labels
# - Save script and settings files
declare -a TABLE_PREFERENCES_DIALOG=(
    "${YAD_COMMON_ARGS[@]}"
    --paned
    --tab "Tab1"
    --tab "Tab2"
    --button "Set _Labels":3
    --button "Save _Files":2
    --button "Cancel":1
    --button "_OK":0
    )

# Dialog #3 top pane, call start_table_preferences_meta_pane()

# Dialog #3, bottom pane, before adding data:
declare -a IACT_TYPES_LIST=(
    --text "Click on an interaction type to set column preferences."
    --list
    --separator "${YSEP}"
    --column "Included":IMG
    --column "Interaction Type":TEXT
)


### Dialog #4: Interaction Settings Dialog
### Use in function: show_interaction_preferences_dialog()
# Primary yad dialog, set column preferences for the interaction.
declare -a INTERACTION_PREFERENCES_DIALOG=(
    --paned
    --tab="Tab1"
    --tab="Tab2"
    --button "Show S_RM":4
    --button "Show S_QL":2
    --button "Cancel":1
    --button "_Ok":0
    )

# Dialog #4 top pane, before data added:
declare -a IACT_TOP_PANE=(
    --tabnum=1
    --form
    --separator "${YSEP}"
    --field "Interaction":RO
    --field "Include":CHK
    --field "Autoload Tag"
    )


# Dialog #4 bottom pane, before data added:
declare -a IACT_LIST_PANE=(
    --tabnum=2
    --list
    --always-print-result
    --separator "${YSEP}"
    --print-all
    --editable
    --editable-cols 7
    --column "Column Name":TEXT
    --column "Type":TEXT
    --column "Param":CHK
    --column "Result":CHK
    --column "Readonly":CHK
    --column "Hide":CHK
    --column "Label":TEXT
)

# Set SRM Globals dialog (dialog #9 for now)
declare -a SRM_GLOBALS_DIALOG=(
    "${YAD_COMMON_ARGS[@]}"
    --button "Cancel":1
    --button "Save Changes":0
    --form
    --columns 2
    --field "Tag 1"
    --field "Tag 2"
    --field "Tag 3"
    --field "Tag 4"
    --field "Tag 5"
    --field "Value 1"
    --field "Value 2"
    --field "Value 3"
    --field "Value 4"
    --field "Value 5"
)


declare COLS_QUERY="\
SELECT c.COLUMN_NAME,
       UPPER(c.DATA_TYPE) AS DATA_TYPE,
       c.CHARACTER_MAXIMUM_LENGTH,
       c.COLUMN_TYPE,
       NULLIF(c.IS_NULLABLE,'NO') AS nullable,
       c.NUMERIC_PRECISION,
       c.NUMERIC_SCALE,
       c.CHARACTER_MAXIMUM_LENGTH,
       c.COLUMN_DEFAULT,
       CASE WHEN INSTR(c.EXTRA,'auto_increment')  THEN 'YES' ELSE NULL END AS autoinc,
       CASE WHEN INSTR(c.COLUMN_KEY,'PRI')        THEN 'YES' ELSE NULL END AS prikey,
       CASE WHEN tc.CONSTRAINT_TYPE='FOREIGN KEY' THEN 'YES' ELSE NULL END AS forkey
  FROM COLUMNS c
       LEFT JOIN KEY_COLUMN_USAGE kcu
             ON c.TABLE_NAME=kcu.TABLE_NAME
                AND c.TABLE_SCHEMA=kcu.REFERENCED_TABLE_SCHEMA
                AND c.COLUMN_NAME=kcu.COLUMN_NAME
       LEFT JOIN TABLE_CONSTRAINTS tc
             ON kcu.CONSTRAINT_NAME=tc.CONSTRAINT_NAME
                AND c.TABLE_SCHEMA=tc.CONSTRAINT_SCHEMA
"

# gsf_callback_iact_records()
# Scans and expands interaction records into arrays, to
# Prepare the environment to look like it would look if
# it were in the interaction dialog (#4), for writing
# a file.
#
# Access the data in the record by calling
# gsf_callback_prefs_rows()
gsf_callback_iact_records()
{
    local IACT_NAME callback="$1"
    local IFS="${FSEP}"
    local -a IACT_COL_PREFS
    for IACT_NAME in "${IACT_NAMES[@]}"; do
        IACT_COL_PREFS=( $( echo "${IACT_DATA[$IACT_NAME]}" ) )
        $callback
    done
}

include_current_iact_record()
{
    local IFS="${YSEP}"
    local -a row=( $( echo "${IACT_COL_PREFS}" ) )
    [ "${row[0]}" = "TRUE" ]
}


# gsf_callback_prefs_rows()
# Scans and expands preferences data into arrays, which are made 
# accessible through a callback function.
# 
# This function is designed to be called from the script-writing options
# of Dialog #4, from which the IACT_COL_PREFS array is instantiated from
# the results of a column preferences page.  That said, the same array
# could be instantiated in other contexts, in particular, in processing
# an entire GSF settings file by creating an IACT_COL_PREFS array from
# each interaction record.
gsf_callback_prefs_rows()
{
    local callback="$1"
    local IFS="${YSEP}"
    local FIELD_NAME
    local -t CALLBACK_ROW
    local -t FIELD_ROW
    local rowstr fieldstr
    local -i flag_slink flag_autoinc flag_prikey flag_forkey

    is_slink()   { [ $flag_slink   -eq 0 ]; }
    is_autoinc() { [ $flag_autoinc -eq 0 ]; }
    is_prikey()  { [ $flag_prikey  -eq 0 ]; }
    is_forkey()  { [ $flag_forkey  -eq 0 ]; }

    for rowstr in "${IACT_COL_PREFS[@]}"; do
        IFS="${YSEP}"
        CALLBACK_ROW=( $( echo "${rowstr}" ) )
        if [ "${#CALLBACK_ROW[@]}" -gt 2 ]; then
            flag_slink=1; flag_autoinc=1; flag_prikey=1; flag_forkey=1

            # Find field's matching RESULT_ROW:
            for fieldstr in "${RESULT_ROWS[@]}"; do
                FIELD_NAME=$( CB_ROW_NAME )

                SLINK=$( GSF_SESSION_LINK_VALUE "$FIELD_NAME" )
                flag_slink=$?

                IFS="${FSEP}"
                FIELD_ROW=( $( echo "${fieldstr}" ) )
                if [ "${FIELD_ROW[$COL_NAME]}" = $FIELD_NAME ]; then
                    if [ -n "${FIELD_ROW[$COL_AUTOINC]}" ]; then flag_autoinc=0; fi
                    if [ -n "${FIELD_ROW[$COL_PRIKEY]}"  ]; then flag_prikey=0; fi
                    if [ -n "${FIELD_ROW[$COL_FORKEY]}"  ]; then flag_forkey=0; fi

                    $callback
                    break
                fi
            done
            # $callback
        fi
    done
}

gsf_iact_callback_prefs_rows()
{
    local IACT_NAME="$1" callback="$2"
    local IFS="${FSEP}"
    local -a IACT_COL_PREFS
    IACT_COL_PREFS=( $( echo "${IACT_DATA[$IACT_NAME]}" ) )
    gsf_callback_prefs_rows "${callback}"
}

# Use this function to open and parse an IACT preferences
# record.
# Call this function with two parameters,
# - The interaction name
# - The callback function name
#
# The callback function will be invoked for every line
# of the IACT preferences record.  The callback function
# can read the contents of the current line through the
# CALLBACK_ROW array whose contents should be accessed by
# one of the series of CB_ROW_ functions defined below.
#
# The first line of the IACT Prefs record contains the meta
# information.  Currently, it contains only the "include"
# flag.  The callback function must distinguish between
# the line types by considering the the element count of the
# CALLBACK_ROW array.
# of
# element.  The first 
# Use this function to refer to a additional interaction type
# while in the process of using a first interaction type.
# For example, while processing the Edit interaction, it is
# necessary to refer to the Delete interaction to see which
# parameters are necessary to process the delete procedure.
gsf_callback_iact_info()
{
    local rowstr IACT_NAME="$1" callback="$2"
    local IFS="${FSEP}"
    local -a LOCAL_COL_PREFS CALLBACK_ROW
    local -i CB_EL_COUNT=0
    LOCAL_COL_PREFS=( $( echo "${IACT_DATA[$IACT_NAME]}" ) )

    IFS="${YSEP}"
    for rowstr in "${LOCAL_COL_PREFS[@]}"; do
        CALLBACK_ROW=( $( echo "${rowstr}" ) )
        CB_EL_COUNT="${#CALLBACK_ROW[@]}"
        $callback
        if [ $? -ne 0 ]; then
            break
        fi
    done
}

gsf_IACT_included()
{
    local name="$1"
    local -i included=1
    gIi_callback()
    {
        if [ "${CB_EL_COUNT}" -lt 3 ]; then
            if [ "${CALLBACK_ROW[0]}" = "TRUE" ]; then
                included=0
            fi
            return 1
        fi
    }
    gsf_callback_iact_info "$name" "gIi_callback"

    return $included
}

markup_tablify()
{
    local -a arr=( "${@:1}" )
    local -i idx=0 stop="${#arr[@]}"
    local -i len maxlen=0
    local val

    # Determine the longest left-column value:
    while [ $idx -lt $stop ]; do
        if  [ $(( idx % 2 )) -eq 0 ]; then
            len="${#arr[$idx]}"
            if [ "${len}" -gt "$maxlen" ]; then
                maxlen="${len}"
            fi
        fi
        (( ++idx ))
    done

    local fstr="<tt><b>%${maxlen}s : </b>"

    # Restart loop, printing this time:
    idx=0
    while [ $idx -lt $stop ]; do
        val="${arr[$idx]}"
        if  [ $(( idx % 2 )) -eq 0 ]; then
            printf "${fstr}" "${val}"
        else
            echo "${val}</tt>"
        fi
        (( ++idx ))
    done
}



# These simple functions interpret the callback data from function
# gsf_callback_prefs_rows().
CB_ROW_NAME()       { echo "${CALLBACK_ROW[0]}"; }
CB_ROW_TYPE()       { echo "${CALLBACK_ROW[1]}"; }
CB_ROW_IS_PARAM()   { [ "${CALLBACK_ROW[2]}" = "TRUE" ]; }
CB_ROW_IS_RESULT()  { [ "${CALLBACK_ROW[3]}" = "TRUE" ]; }
CB_ROW_IS_READONLY(){ [ "${CALLBACK_ROW[4]}" = "TRUE" ]; }
CB_ROW_IS_HIDDEN()  { [ "${CALLBACK_ROW[5]}" = "TRUE" ]; }

GSF_DEFAULT_FIELD_LABEL()
{
    local val target="$1"
    local -i ndx
    ndx=$( index_in_array "$target" "${GSF_FIELD_NAMES[@]}" )
    if [ $? -eq 0 ]; then
        val="${GSF_FIELD_LABELS[$ndx]}"
        if [ -n "$val" ]; then
            echo "$val"
            return 0
        fi
    fi
    return 1
}

GSF_SESSION_LINK_VALUE()
{
    local val target="$1"
    local -i ndx
    ndx=$( index_in_array "$target" "${GSF_FIELD_NAMES[@]}" )
    if [ $? -eq 0 ]; then
        val="${GSF_FIELD_SLINKS[$ndx]}"
        if [ -n "$val" ]; then
            echo "$val"
            return 0
        fi
    fi
    return 1
}

CB_ROW_LABEL()
{
    if [ "${CALLBACK_ROW[6]}" ]; then
        echo "${CALLBACK_ROW[6]}"
        return 0
    else
        GSF_DEFAULT_FIELD_LABEL "${CALLBACK_ROW[0]}"
    fi
}

# Save column indexes to global variables for repeated access
collect_column_indexes()
{
    declare -i ndx
    declare -i exval=0

    # Use nested function to reuse repeated code.
    # First failure to find skips the rest.
    get_index()
    {
        if [ $exval -eq 0 ]; then
            ndx=$( find_column_index "$1" )
            exval=$?
            if [ $exval -ne 0 ]; then
                echo "Can't find column '$1'." >&2
                exit $exval
            fi
        fi
    }

    get_index "COLUMN_NAME"; COL_NAME=$ndx
    get_index "DATA_TYPE";   COL_TYPE=$ndx
    get_index "COLUMN_TYPE"; COL_COLTYPE=$ndx
    get_index "autoinc";     COL_AUTOINC=$ndx
    get_index "prikey";      COL_PRIKEY=$ndx
    get_index "forkey";      COL_FORKEY=$ndx
    get_index "COLUMN_DEFAULT";    COL_DEFAULT=$ndx
    get_index "NUMERIC_PRECISION"; COL_PRECISION=$ndx
    get_index "NUMERIC_SCALE";     COL_SCALE=$ndx

    get_index "CHARACTER_MAXIMUM_LENGTH"; COL_MAXLEN=$ndx
}

# Get field names from global table information
update_field_names_array()
{
    GSF_FIELD_NAMES=()

    declare rowstr
    declare -a row
    declare -i ndx=0
    local IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "${rowstr}" ) ) 
        GSF_FIELD_NAMES[$ndx]="${row[$COL_NAME]}"
        GSF_FIELD_LABELS[$ndx]=""
        GSF_FIELD_SLINKS[$ndx]=""
        (( ndx++ ))
    done
}

get_iact_meta_vals_str_from_IACT_DATA()
{
    local -i exval
    local itype="$1"
    local metastr

    local -a lines
    local IFS="${FSEP}"

    # split record to fields, first field is meta string:
    lines=( $( echo "${IACT_DATA[$itype]}" ) )
    echo "${itype}${YSEP}${lines[0]}"
}

get_iact_meta_vals_str_from_result()
{
    local -a arr_cur lines
    local LSEP="${IFS:0:1}"
    local IFS=$'\n'
    lines=( $( echo "$1" ) )

    local line
    IFS="${YSEP}"
    for line in "${lines[@]}"; do
        arr_cur=( $( echo "$line" ) )
        if [ "${#arr_cur[@]}" -lt 4 ]; then
            break
        fi
    done

    IFS="${LSEP}"
    echo "${arr_cur[*]}"
}

get_iact_list_data_str_from_IACT_DATA()
{
    local -i exval
    local itype="$1"
    local metastr

    local -a lines line
    local IFS="${FSEP}"
    lines=( $( echo "${IACT_DATA[$itype]}" ) )
    for line in "${lines[@]:1}"; do
        echo -n "$line"
    done
}

get_iact_list_data_str_from_result()
{
    local name field
    local -a arr_cur lines
    local LSEP="${IFS:0:1}"
    local IFS=$'\n'
    lines=( $( echo "${1}" ) )

    local line
    IFS="${YSEP}"
    for line in "${lines[@]}"; do
        arr_cur=( $( echo "$line" ) )
        if [ "${#arr_cur[@]}" -lt 4 ]; then
            name="${arr_cur[0]}"
            break
        fi
    done

    for line in "${lines[@]}"; do
        IFS="${YSEP}"
        arr_cur=( $( echo "$line" ) )
        if [ "${#arr_cur[@]}" -gt 3 ]; then
            IFS="${LSEP}"
            echo -n "${arr_cur[*]}${IFS}"
        fi
    done
}

make_iact_default_data_str()
{
    local itype="$1"

    # If no saved value, return a default string to start with:
    local IFS rowstr colname coltype
    local -a row

    is_auto() { [ -n "${row[$COL_AUTOINC]}" ]; }
    is_pri()  { [ -n "${row[$COL_PRIKEY]}" ]; }
    is_for()  { [ -n "${row[$COL_FORKEY]}" ]; }

    is_auto_assign() { is_auto || ( is_pri && ! is_for ) }

    # Reset IFS to parse fields from rowstr from bashmysql:
    IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "$rowstr") )

        colname="${row[$COL_NAME]}"

        # Get data type from DATA_TYPE result:
        coltype="${row[$COL_TYPE]}"
        # CHAR and INT types also need length value:
        if [ "${#coltype}" -ge 4 -a "${coltype: -4}" = "CHAR" ]; then
            coltype="${coltype}(${row[$COL_MAXLEN]})"
        elif [ "${#coltype}" -ge 3 -a "${coltype: -3}" = "INT" ]; then
            if [[ "${row[$COL_COLTYPE]}" =~ "unsigned" ]]; then
                coltype="$coltype UNSIGNED"
            fi
        fi
        
        # 'Name' and 'Type' columns:
        echo -n "${colname}${YSEP}${coltype}"

        # The Param and Result columns a flags to include the field
        # in the respective domain.  Fields for which the Param flag
        # is set will be include the field in the parameter list.
        # Likewise, fields for which the Result flag will be included
        # in the results by adding the field to the  SELECT clause
        # of the query.

        # 'Param' column:
        if is_pri; then
            if is_for; then
                # Foreign keys don't increment, so they must be set.
                # Eventually, hopefully, a session link will set this.
                echo -n "${YSEP}TRUE"
            elif [[ " Add Export Import " =~ "$itype" ]]; then
                # Non-foreign primary key is identity field. It should
                # not be set the the imported file.
                echo -n "${YSEP}FALSE"
            else
                # Otherwise non-foreign primary key identifies the
                # desired record.  It should be included:
                echo -n "${YSEP}TRUE"
            fi
        elif [[ " Add Update Import " =~ "$itype" ]]; then
            # All value fields (non primary) for record writing interactions
            echo -n "${YSEP}TRUE"
        else
            echo -n "${YSEP}FALSE"
        fi

        # 'Result' column:
        if is_pri; then
            if [[ " List Read Update " =~ " $itype " ]]; then
                # All primary keys needed when a record is to be accessed again
                echo -n "${YSEP}TRUE"
            else
                # Otherwise, primary key not needed
                echo -n "${YSEP}FALSE"
            fi
        elif [[ " List Read Update Export " =~ "$itype" ]]; then
            # Non-key value fields for reading interactions
            echo -n "${YSEP}TRUE"
        else
            echo -n "${YSEP}FALSE"
        fi

        # Set 'Readonly' and 'Hide' flags
        if [[ " Delete Import Export " =~ "$itype" ]]; then
            # These interactions have no record output, they're always false
            echo -n "${YSEP}FALSE${YSEP}FALSE"
        elif is_pri && ! ( is_auto_assign && [ "$itype" = "Add" ] ); then
            # Primary keys are always readonly and generally hidden,
            # except when it's an auto-assign (autoinc or primary non-foreign)
            # in an Add interaction, when it's never included in forms.
            echo -n "${YSEP}TRUE${YSEP}TRUE"
        else
            echo -n "${YSEP}FALSE${YSEP}FALSE"
        fi

        # Blank element for the label
        echo -n "${YSEP}"
        echo -n "${YSEP}"
        echo -n "${FSEP}"

    done
}

# Call this function to setup a new table.
prepare_default_IACT_DATA()
{
    IACT_DATA=()
    local name result al_tag
    local include="TRUE"

    for name in "${IACT_NAMES[@]}"; do
        if [ $name = "List" ]; then
            al_tag="page"
        elif [[ " Add Read Update " =~ " ${name} " ]]; then
            al_tag="dialog"
        else
            al_tag=""
        fi

        result=$( make_iact_default_data_str "$name" )
        IACT_DATA[$name]="${include}${YSEP}${al_tag}${YSEP}${FSEP}${result}"
    done
}

# make_iact_choices_string()
# Converts result of dialog #4 to a string with table fields
# separated by FSEP and the field preferences separated by YSEP.
# $1 should be the IACT_NAME
# $2 should be a result string from Dialog #4
make_iact_choices_string()
{
    # Parse parameters:
    local iact_name="$1"
    local IFS=$'\n'
    local -a lines
    lines=( $(echo "$2" ) )

    local line
    local -a choices row iact_frows

    # These are used to set and build a record value:
    local iact_incl
    local meta_str

    for line in "${lines[@]}"; do
        IFS="${YSEP}"
        row=( $( echo "${line}" ) )

        # Identify meta fields row by name:
        # if [ "${row[0]}" = "${iact_name}" ]; then
        # or
        # Identify meta fields row by element count:
        if [ "${#row[@]}" -lt 4 ]; then
            IFS="${YSEP}"
            meta_str="${row[*]:1}"
        else
            IFS="${YSEP}"
            # Add extra YSEP in case of empty final field:
            rowstr="${row[*]}${YSEP}"

            IFS="${FSEP}"
            iact_frows=( "${iact_frows[@]}" "${rowstr}" )
        fi
    done

    IFS="${FSEP}"
    echo -n "${meta_str}${FSEP}${iact_frows[*]}"
}

# save_iact_choices():
# Saves the result of make_iact_choices_string() to IACT_DATA
# to reopen and to serialize to disk.
save_iact_choices()
{
    local -i exval
    local choices
    local iact_name="$1"
    local result="$2"
    choices_str=$( make_iact_choices_string "$iact_name" "$result" )

    exval=$?
    if [ $exval -eq 0 ]; then
        IACT_DATA[$iact_name]="$choices_str"
    fi
}

# Seeks element in array that matches $1.  Returns 0 if found,
# 1 if not found.  If found, the index is "echoed".
index_in_array()
{
    local target="$1"
    local el
    local -i ndx=0
    for el in "${@:2}"; do
        if [ "$el" = "$target" ]; then
            echo "$ndx"
            return 0
        fi
        (( ndx++ ))
    done
    return 1
}

# Simply confirms if a string is in an array.
# Returns 0 if found, 1 if not.
string_in_array()
{
    local target="$1"
    local el
    for el in "${@:2}"; do
        if [ "$el" = "$target" ]; then
            return 0
        fi
    done
    return 1
}

confirm_dbase_name() { string_in_array "${GF_DBNAME}" "${DBASE_NAMES[@]}"; }
confirm_table_name() { string_in_array "${GF_TNAME}" "${TABLE_NAMES[@]}"; }
confirm_iact_name()  { string_in_array "$1" "${IACT_NAMES[@]}"; }

set_dbase_name()
{
    GF_TNAME=
    TABLE_NAMES=()
    if string_in_array "$1" "${DBASE_NAMES[@]}" ; then
        GF_DBNAME="$1"
        local IFS=$'\n'
        TABLE_NAMES=( $( mysql "${GF_DBNAME}" -BN -e "show tables" ) )
    else
        echo "'$1' is not a database name on this server." >&2
        exit 1
    fi
}

set_table_name()
{
    if string_in_array "$1" "${TABLE_NAMES[@]}"; then
        GF_TNAME="$1"
    else
        echo "'$1' is not a table name in the ${GF_DBNAME} database." >&2
        exit 1
    fi
}

auto_save()
{
    if [ "${GF_FILEPATH_SQL}" ]; then
        echo "Saving SQL to ${GF_FILEPATH_SQL}" >&2
        save_sql_to_file "${GF_FILEPATH_SQL}"
    fi

    if [ "${GF_FILEPATH_SRM}" ]; then
        echo "Saving SRM to ${GF_FILEPATH_SRM}" >&2
        save_srm_to_file "${GF_FILEPATH_SRM}"
    fi
}

attempt_gsf_open()
{
    local IFS='.'
    local base path
    local arr=( $( echo "$1" ) )
    if [ "${#arr[@]}" -eq 1 ]; then
        base="${arr}"
        path="${arr}.gsf"
    else
        base="${arr[0]}"
        path="${1}"
    fi

    if [ -f "${path}" ]; then
        GF_FILE_ARG="${path}"
        set_file_path_defaults "${path}"
        gsf_read_settings_from_file "${path}"
    fi
}

parse_args()
{
    local arg state
    local -i reev
    local gsfname dbname tname

    # Interpret an argument without a state as a gsfname
    set_state()
    {
        arg="$1"
        if [ "$state" ]; then
            case "$state" in
                g) gsfname="${arg}" ;;
                d) dbname="${arg}" ;;
                t) tname="${arg}" ;;
                c) CL_CMD="${arg}" ;;
            esac
        else
            gsfname="${arg}"
        fi
    }

    regx='-(c|d|g|t)'

    for arg in "$@"; do
        [[ "${arg}" =~ $regx ]]
        reev=$?

        case "$reev" in
            0) state="${BASH_REMATCH[1]}" ;;

            1) set_state "${arg}"
               unset state
               ;;

            2) echo "Invalid regular expression." >&2 ;;
        esac
    done

    if [ $gsfname ]; then
        attempt_gsf_open "${gsfname}"
    elif [ $dbname ]; then
        set_dbase_name "${dbname}"
        if [ $tname ]; then
            set_table_name "${tname}"
        fi
    fi

    if [ "$CL_CMD" = "save" ]; then
        if [ "$GF_TNAME" ]; then
            set_file_path_defaults "${PWD}/${GF_TNAME}.gsf"
            collect_table_info "auto_save"
            return 1
        fi
    fi

    return 0
}

# Using the first character of IFS as the separator, this function creates a
# string of values from a specified column of a list result.
#
# For example, local -a arr=( $( array_str_from_list_result 1 "$result" ) )
# will make an array from the second column of the list result.
array_str_from_list_result()
{
    local -a lines vals
    local line
    local -i col="$1"

    # Save IFS character before we change IFS
    local VSEP="${IFS:0:1}"

    # List results separated by newlines:
    local IFS=$'\n'
    lines=( $( echo "$2" ) )

    # Set IFS to split each line into values:
    IFS="${YSEP}"
    for line in "${lines[@]}"; do
        vals=( $( echo "$line" ) )
        # Echo each value, followed by the VSEP value we saved above:
        echo -n "${vals[$col]}${VSEP}"
    done
}

# Uses first parameter as subject value, then puts the rest
# of the parameters into a list element.
pick_from_array()
{
    local subject="$1"

    local cmd=(
        "${YAD_COMMON_ARGS[@]}"
        --list
        --text "Select a ${subject} from the following list."
        --button "_Open File":2
        --button "Cancel":1
        --button "OK":0
        --no-headers
        --column "${subject}":TEXT
        "${@:2}"
    )

    local -i exval

    result=$( yad "${cmd[@]}" )
    exval=$?
    case "$exval" in
        0)
            local IFS="${YSEP}"
            arr=( $( echo "${result}" ) )
            echo "${arr[0]}"
            return 0
            ;;
        2)
            open_gsf_file
            return 1
            ;;
        *)
            return $exval ;;
    esac

    return 0
}

# Dialog #1: Get database name from available databases.
show_select_dbase_dialog()
{
    local -a dbnames
    local -i exval
    local result

    result=$( pick_from_array "Database" "${DBASE_NAMES[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        set_dbase_name "${result}"
    fi
    return $exval
}

# Dialog 2: Get table name from list of tables in current database.
show_select_table_dialog()
{
    local -i exval
    local result

    result=$( pick_from_array "Table" "${TABLE_NAMES[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        set_table_name "${result}"
    fi
    return $exval
}

## Dialog #3: 
show_table_preferences_dialog()
{
    local result
    local -i exval
    local -i PLUG_NUM=$(( G_PLUG_NUM++ ))
    local -a row
    local IFS="${YSEP}"

    if [ -z "${GF_FILE_ARG}" ]; then
        set_file_path_defaults "${PWD}/${GF_TNAME}.gsf"
    fi

    while true; do
        result=$(
            build_table_preferences_dialog
            )
        exval=$?

        case $exval in
            # Two-column lines means result will look like &List&,
            # resulting in a two-element array with the import value
            # at offset 1
            0)
                IFS="${YSEP}"
                row=( $( echo "$result" ) )
                show_interaction_preferences_dialog "${row[1]}"
                ;;
            1|252) break ;; # Pressed  Cancel (1) or ESC or window close (252)
            3) show_save_files_dialog ;;
            5) show_default_column_slinks_dialog ;;
            7) show_default_column_labels_dialog ;;
            9) show_srm_globals_dialog ;;
        esac
    done
}

# Dialog #3 build string for data array
get_table_prefs_data_str()
{
    local name
    local LSEP="${IFS:0:1}"
    for name in "${IACT_NAMES[@]}"; do
        if gsf_IACT_included "${name}"; then
            echo -n "gtk-yes${LSEP}"
        else
            echo -n "gtk-no${LSEP}"
        fi
        
        echo -n "${name}${LSEP}"
    done
}

# Dialog #3 complete dialog
build_table_preferences_dialog()
{
    local -i fcount=$( get_fields_count )

    # Collect information to put in the text section of
    # the dialog.  This used to be the "meta" pane.
    local -a meta=(
        "Database" "${GF_DBNAME}"
        "Table" "${GF_TNAME}"
        "Field Count" "${fcount}"
    )

    if [ -n "${GF_FILE_ARG}" ]; then
        meta=( "${meta[@]}"
               "Settings File" "${GF_FILEPATH_GSF}"
            )
    fi

    local -a row_data
    row_data=( $( get_table_prefs_data_str ) )
    
    local txt=$( markup_tablify "${meta[@]}" )

    local -a cmd=(
            "${YAD_COMMON_ARGS[@]}"
            --list
            "${IACT_TYPES_LIST[@]}"
            --text "${txt}"
            "${row_data[@]}"
            # "${IACT_NAMES[@]}"
            --button "Set SRM _Globals":9
            --button "Set L_abels":7
            --button "Set L_inks":5
            --button "Save _Files":3
            --button "Cancel":1
            --button "_OK":0
    )
    yad "${cmd[@]}"
}


# Dialog #4: Set field usage and display flags for an interaction type
show_interaction_preferences_dialog()
{
    local name=$1
    local itext="Interaction Editor for ${GF_DBNAME}.${GF_TNAME}"

    # IFS for parsing our stuff:
    IFS="${YSEP}"
    local -a meta_vals=( $( get_iact_meta_vals_str_from_IACT_DATA "${name}" ) )
    local -a list_vals=( $( get_iact_list_data_str_from_IACT_DATA "${name}" ) )

    local result
    local -i exval
    local -i PLUG_NUM=$(( G_PLUG_NUM++ ))

    local -a top_pane=(
        --plug "${PLUG_NUM}"
        --text "${itext}"
        "${IACT_TOP_PANE[@]}"
    )


    local -a list_pane=(
        --plug "${PLUG_NUM}"
        "${IACT_LIST_PANE[@]}"
    )

    local -a paned_dialog=(
        --key "${PLUG_NUM}"
        "${YAD_COMMON_ARGS[@]}"
        "${INTERACTION_PREFERENCES_DIALOG[@]}"
    )

    local script_text

    while true; do
        result=$(
            yad "${top_pane[@]}" "${meta_vals[@]}" &
            yad "${list_pane[@]}" "${list_vals[@]}" &
            yad "${paned_dialog[@]}"
              )
        exval=$?

        case $exval in
            0) save_iact_choices "$name" "${result}"; break ;;
            2|4)
                local cmd_to_call
                local script_type
                if [ $exval -eq 2 ]; then
                    cmd_to_call="gsf_write_script_sql"
                    script_type=SQL
                else
                    cmd_to_call="gsf_write_script_srm"
                    script_type=SRM
                fi

                IFS="${FSEP}"
                local PROC_ROOT="App_${GF_TNAME}_"

                local -a IACT_COL_PREFS
                IACT_COL_PREFS=( $( make_iact_choices_string "${name}" "${result}" ) )

                script_text=$( $cmd_to_call "${name}" )
                if [ $? -eq 0 ]; then
                    # Show dialog #7:
                    show_script_dialog "${script_text}" "${script_type}";
                fi

                # Update array for re-initialize the dialog:
                IFS="${FSEP}"
                meta_vals=( $( get_iact_meta_vals_str_from_result "${result}" ) )
                list_vals=( $( get_iact_list_data_str_from_result "${result}" ) )
                ;;
            1|252) break ;;
        esac
    done
}

## Dialog #5: Set default field labels for current table.
#
# Tables with few fields can use a form, but longer lists require
# a scrolling list with which to set default column names.
show_default_column_labels_dialog()
{
    local -i fcount=$( get_fields_count )
    if [ "$fcount" -lt 15 ]; then
        start_default_columns_array_form_dialog "labels"
    else
        start_default_columns_array_list_dialog "labels"
    fi
}

## Dialog #6: Set default field labels for current table.
#
# Tables with few fields can use a form, but longer lists require
# a scrolling list with which to set default column names.
show_default_column_slinks_dialog()
{
    local -i fcount=$( get_fields_count )
    if [ "$fcount" -lt 15 ]; then
        start_default_columns_array_form_dialog "slinks"
    else
        start_default_columns_array_list_dialog "slinks"
    fi
}

# String variables to be used as text options for
# function start_default_columns_array_form_dialog()
declare GSF_DIALOG_TEXT_DEFAULT_LABELS="\
<b>Setting Default Field Labels</b>\n\n Use this \
dialog to set user-friendly labels for fields that \
will used when presenting forms and tables."
declare GSF_DIALOG_TEXT_SESSION_LINKS="\
<b>Setting Session Links</b>\n\nUse this dialog to \
establish the relationship between the fields in \
the table with session variables."

# Helper function for Dialogs #5 and #6 (using a form display)
start_default_columns_array_form_dialog()
{
    local atype="$1"
    local txt

    if [ $atype = 'slinks' ]; then
        txt="${GSF_DIALOG_TEXT_SESSION_LINKS}"
    else
        txt="${GSF_DIALOG_TEXT_DEFAULT_LABELS}"
    fi

    local -a cmd
    cmd=( "${YAD_COMMON_ARGS[@]}"
          --text "$txt"
          --always-print-result
          --form
        )

    local rowstr
    local -a row arr_data

    # Add list rows
    local -i ndx="${#cmd[@]}"
    local IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "$rowstr") )
        cmd[ $(( ndx++ )) ]="--field"
        cmd[ $(( ndx++ )) ]="${row[$COL_NAME]}:"
    done

    if [ ${atype} = "labels" ]; then
        cmd=( "${cmd[@]}" "${GSF_FIELD_LABELS[@]}" )
    elif  [ ${atype} = "slinks" ]; then
        cmd=( "${cmd[@]}" "${GSF_FIELD_SLINKS[@]}" )
    fi

    local -i exval
    local result
    result=$( yad "${cmd[@]}" )
    exval=$?

    if [ $exval -eq 0 ]; then
        IFS="${YSEP}"
        if [ ${atype} = "labels" ]; then
            GSF_FIELD_LABELS=( $( echo "$result" ) )
        elif  [ ${atype} = "slinks" ]; then
            GSF_FIELD_SLINKS=( $( echo "$result" ) )
        fi
    fi

    if [ $? -ne 0 ]; then
        echo "yad failed:" >&2
        printf "'%s'\n" "${cmd[@]}" >&2
        return 1
    else
        return 0
    fi
}

# Helper function for Dialogs #5 and #6 (using a list display)
start_default_columns_array_list_dialog()
{
    local atype="$1"

    local -a cmd

    cmd=( "${YAD_COMMON_ARGS[@]}"
          --list
          --always-print-result
          --print-all
          --editable
          --editable-cols 2
          --column "Column":TEXT
          --column "Label":TEXT
        )

    local rowstr
    local -a row arr_data

    # Add list rows
    local -i ndx="${#cmd[@]}"
    local -i vndx=0
    local IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "$rowstr") )
        cmd[ $(( ndx++ )) ]="${row[$COL_NAME]}"
        if [ ${atype} = "labels" ]; then
            cmd[ $(( ndx++ )) ]="${GSF_FIELD_LABELS[$(( vndx++ ))]}"
        elif  [ ${atype} = "slinks" ]; then
            cmd[ $(( ndx++ )) ]="${GSF_FIELD_SLINKS[$(( vndx++ ))]}"
        fi
    done

    local result
    local -i exval
    result=$( yad "${cmd[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        if [ ${atype} = "labels" ]; then
            GSF_FIELD_LABELS=( $( array_str_from_list_result 1 "$result" ) )
        elif  [ ${atype} = "slinks" ]; then
            GSF_FIELD_SLINKS=( $( array_str_from_list_result 1 "$result" ) )
        fi
    fi
}

## Dialog #7:
show_save_files_dialog()
{
    local -a cmd
    cmd=(
        "${YAD_COMMON_ARGS[@]}"
        --form
        --field "Write settings file":CHK "TRUE"
        --field "GSF file name":SFL "${GF_FILEPATH_GSF}"
        --field "Write SQL script":CHK "TRUE"
        --field "SQL file name":SFL "${GF_FILEPATH_SQL}"
        --field "Write SRM script":CHK "TRUE"
        --field "SRM file name":SFL "${GF_FILEPATH_SRM}"
    )

    local result=$( yad "${cmd[@]}" )
    local -i exval=$?

    if [ $exval -eq 0 ]; then
        local IFS="${YSEP}"
        local -i index=0
        rarr=( $( echo "${result}" ) )

        if [ "${rarr[$index]}" = "TRUE" ]; then
            save_settings_to_file "${rarr[$index+1]}"
        fi

        (( index+=2 ))

        if [ "${rarr[$index]}" = "TRUE" ]; then
            save_sql_to_file "${rarr[$index+1]}"
        fi

        (( index+=2 ))

        if [ "${rarr[$index]}" = "TRUE" ]; then
            save_srm_to_file "${rarr[$index+1]}"
        fi
    fi
}

## Dialog #8 Show an SQL or SRM script.
show_script_dialog()
{
    local script="$1"
    local stype="$2"
    local -a cmd=(
        "${YAD_COMMON_ARGS[@]}"
        --text="${stype} script for table '${GF_TNAME}' of database '${GF_DBNAME}'."
        --text-info
        --listen
    )

    yad "${cmd[@]}" <<< "$script"
}


## Dialog #9 
show_srm_globals_dialog()
{
    local -i exval
    local result
    while true; do
        result=$( yad "${SRM_GLOBALS_DIALOG[@]}" "${GSF_SRM_GLOBALS[@]}" )
        exval=$?
        case $exval in
            0)
                local IFS="${YSEP}"
                GSF_SRM_GLOBALS=( $( echo "${result}${YSEP}" ) )
                break ;;
            1|252)
                break ;; # Pressed  Cancel (1) or ESC or window close (252)
        esac
    done
}


use_table_info()
{
    GF_PROC_ROOT="App_${GF_TNAME}_"
    collect_column_indexes
    update_field_names_array
    prepare_default_IACT_DATA
    $use_table_info_callback
}

collect_table_info()
{
    local use_table_info_callback
    if [ -z $CL_CMD ]; then
        use_table_info_callback="${1:-show_table_preferences_dialog}"
    fi

    if ! confirm_dbase_name || ! confirm_table_name ; then
        echo "SQL Injection test failed.  Attempt to set" >&2
        echo "Database name = '${GF_DBNAME}', and" >&2
        echo "Table name = '${GF_TNAME}'" >&2
        exit 1
    fi

    query="\
${COLS_QUERY}
WHERE c.TABLE_SCHEMA='${GF_DBNAME}'
AND c.TABLE_NAME='${GF_TNAME}'"

    source bashmysql -s "${SEPS}" "information_schema" "${query}" -c use_table_info
}

table_get_index_key()
{
    local index_key
    local -i matched=0
    tgik_survey()
    {
        if is_prikey && ! is_forkey; then
            (( matched++ ))
            index_key="$FIELD_NAME"
        fi
    }
    gsf_callback_prefs_rows "tgik_survey"

    if [ $matched -eq 1 ]; then
        echo "$index_key"
        return 0
    fi

    echo "Found $matched keys, should have been 1." >&2
    return 1
}

loop_for_context()
{
    local -i do_loop=0
    local -i do_dbase_loop=$( test -z "$GF_DBNAME"; echo $? )

    local tresult dresult
    local -i exval

    while [ $do_loop -eq 0 ]; do
        if [ $do_dbase_loop -eq 0 ]; then
            show_select_dbase_dialog
            exval=$?
            if [ $exval -ne 0 ]; then
                GF_DBNAME=
                do_dbase_loop=1
                do_loop=1
            fi
        fi

        while [ -n "$GF_DBNAME" ]; do
            reset_for_new_table
            show_select_table_dialog
            exval=$?
            if [ $exval -eq 0 ]; then
                collect_table_info "show_table_preferences_dialog"
            elif [ $do_dbase_loop -ne 0 ]; then
                do_loop=1
                break
            else
                break
            fi
        done
    done
}


parse_args "$@"
exval=$?

if [ $exval -eq 0 ]; then
    if [ -z "$GF_FILE_ARG" ]; then
        if [ -n "$GF_TNAME" -a -n "$GF_DBNAME" ]; then
            collect_table_info "show_table_preferences_dialog"
        else
            loop_for_context
        fi
    fi
fi

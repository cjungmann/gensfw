#!/bin/bash

### TEST ARRAYS SECTION

# This first section of several arrays are designed to be
# applied to the gensfw_srm command to test various actions.

declare -a TEST_AFTER_SIBLING=(
    after_sibling "test_branch/branch/item:1" "result : 2"
)

declare -a TEST_BEFORE_SIBLING=(
    before_sibling "edit/schema/readOnly:true" "before:readOnly"
)

declare -a TEST_DUMP_PATH=(
    flag dump_path --
    message
    "<%CLRSCR>"
    "(TEST_DUMP_PATH)"
    "Dumping an evaluation of an SRMPath string."
    "household/person[interests[writing]][gender:female]"
    --
    
    dump_path "household/person[interests[writing]][gender:female]" --
    message " " "household/person[interests[writing][gender:female]]" --
    dump_path "household/person[interests[writing][gender:female]]" --
    pause --
)

declare -a TEST_LAST_CHILD=(
    last_child "list/result" "last_child:following schema"
)

declare -a TEST_DELETE=(
    delete "test_branch/branch[item:1/name:B1-I1][item:2/name:B1-I2]"
)

# The following tests are not necessary because they are
# used in several of the other tests.  
# Empty arrays to defuse warning, but to skip the tests
declare -a TEST_DISPLAY=()
declare -a TEST_MESSAGE=()
declare -a TEST_PAUSE=()

# Other, non action tests:
declare -a TEST_PATH_EVALUATION=(
    message
    "<%CLRSCR>"
    "(TEST_PATH_EVALUATION)"
    "Testing more complicate SRMPath expressions.  The path expression"
    "is needlessly complicated to test/demonstrate nested predicates."
    --

    display "<%SKIP_COMMENTS>" "household" --

    message "execute:"
    "   after_sibling \"household/person[interests[writing]][gender:female]/gender\" \"household_head : true\""
    --

    after_sibling "household/person[interests[writing]][gender:female]/gender" "household_head : true" --

    message "execute:"
    "   after_sibling \"household/person[interests[running]][gender:female]/gender\" \"household_head : true\""
    --
    after_sibling "household/person[interests[running]][gender:female]/gender" "household_head : true" --

    pause " " --

    message
    " "
    "This was a trick action: there is no person who is both"
    "female and is interested in running.  Only one record was"
    "changed to include the 'household_head' instruction."
    " "
    --

    display "household/person[household_head]" --
)

declare -a TEST_BLANK_LINES=(
    message
    "<%CLRSCR>"
    "Test appropriate line inclusions with adjacent modes with no interveing blank lines."
    display test_no_trailing_blank --
    after_sibling "test_no_trailing_blank/result" "result : 2" --
    message "See what happened after adding result:2 after result:" --
    display test_no_trailing_blank --
    pause
    )

### end of TEST ARRAYS SECTION

# Test for existence and type (array) of $1
name_is_array()
{
    local obj_name="$1"
    local declr=$( declare -p "$obj_name" 2>/dev/null )
    # obj_name must be both found AND declared with declare -a:
    if [ $? -eq 0 ]; then
        if [ "${declr:0:10}" == "declare -a" ]; then
            return 0
        fi
    fi
    return 1
}

# Test for existence and type (function) of $1
name_is_function()
{
    local fname="%2"
    local type=$( LC_ALL=C type -t "$fname" )
    [ "$type" == "function" ]
}

# Used by show_action_test() to parse a path string
get_mode_from_path()
{
    local path="$1"
    local IFS="/"
    local arr=( $( echo "$1" ) )
    echo "${arr[0]}"
    return 0
}

# Seeks an action test array and, if found and not empty,
# prepares the array for use as a demonstration of its
# signature action.
show_action_test()
{
    local name="$1"
    local -a newarr
    array_name="TEST_${name^^}"
    if name_is_array "$array_name"; then
        array_reference="${array_name}[@]"
        local_array=( "${!array_reference}" )
        if [ "${#local_array[@]}" -eq 0 ]; then
            return 0
        elif [ "${local_array[0]}" == "flag" ]; then
            newarr=( "${local_array[@]:3}" )
        else
            local action="${local_array[0]}"
            local path="${local_array[1]}"
            local mode=$( get_mode_from_path "$path" )

            newarr=(
                message
                "<%CLRSCR>"
                "(${array_name})"
                "Testing the output of the '$action' action."
                "Before the change is:"
                --

                display "$mode" --

                message
                " "
                "The output after applying the following commands:"
                "'${local_array[*]}',"
                --

                "${local_array[@]}" --

                display "$mode" --

                pause --
            )

        fi

        ./gensfw_srm gensfw_srm_test.srm "${newarr[@]}"
    fi
}

# Checks list of action words against test arrays demonstrations.
# The names are collected of actions without test arrays and
# an message is given to alert the user to their lack.
announce_missing_action_tests()
{
    local -a ACTIONS=( $( ./gensfw_srm --show_actions ) )
    local -a missing=()
    local action array_name
    local -i longest=0

    for action in "${ACTIONS[@]}"; do
        array_name="TEST_${action^^}"
        if ! name_is_array "$array_name"; then
            missing+=( "$action" )
            if [ "${#action}" -gt "$longest" ]; then
                longest="${#action}"
            fi
        fi
    done

    if [ "${#missing[@]}" -gt 0 ]; then
        echo "The following actions are missing test arrays."
        for act in "${missing[@]}"; do
            printf "'%-${longest}s (%s)'\n" "${act}" "TEST_${act^^}"
        done
        echo

        local bogus
        read -p "Continue with other test, y or n? " -i "n" bogus
        if [ "$bogus" == "n" ]; then
            exit 1
        fi
    fi

}

# Get list of action words from the gensfw_srm command and
# runs a test of the action using a test array that should
# be defined for the action.
test_actions()
{
    announce_missing_action_tests
    
    local -a ACTIONS=( $( ./gensfw_srm --show_actions ) )
    local action

    for action in "${ACTIONS[@]}"; do
        show_action_test "$action"
    done
}


test_complicated_path()
{
    ./gensfw_srm gensfw_srm_test.srm "${TEST_PATH_EVALUATION[@]}"
}


test_actions
test_complicated_path

#!/bin/bash

### TEST ARRAYS SECTION

# This first section of several arrays are designed to be
# applied to the gensfw_srm command to test various actions.

declare -a TEST_AFTER_SIBLING=(
    after_sibling "test_branch/branch/item:1" "result : 2"
)

declare -a TEST_BEFORE_SIBLING=(
    before_sibling "edit/schema/field:id/readOnly:true" "before:readOnly"
)

declare -a TEST_BREAK_IF=(
    break_if "edit/schema/field:id/readOnly:true"
)

declare -a TEST_DUMP_PATH=(
    flag dump_path --
    message
    "<%CLRSCR>"
    "(TEST_DUMP_PATH)"
    "Dumping an evaluation of an SRMPath string."
    "household/person[interests[writing]][gender:female]"
    --
    
    dump_path "household/person[interests[writing]][gender:female]" --
    message " " "household/person[interests[writing][gender:female]]" --
    dump_path "household/person[interests[writing][gender:female]]" --
    pause --
)

declare -a TEST_LAST_CHILD=(
    last_child "list/result" "last_child:following schema"
)

declare -a TEST_DELETE=(
    delete "test_branch/branch[item:1/name:B1-I1][item:2/name:B1-I2]"
)

declare -a TEST_APPEND_MODE=(
    append_mode "last_mode" --
)

# The following tests are not necessary because they are
# used in several of the other tests.  
# Empty arrays to defuse warning, but to skip the tests
declare -a TEST_DISPLAY=()
declare -a TEST_MESSAGE=()
declare -a TEST_PAUSE=()
declare -a TEST_LABEL=()
declare -a TEST_WRITE_FILE=()
declare -a TEST_SKIP=()

# The following are redefinitions of the test cases set above.
# Comment-out tests that should still be run, leave the redefinitions
# for tests that should be skipped.
# TEST_AFTER_SIBLING=()
# TEST_BEFORE_SIBLING=()
# TEST_BREAK_IF=()
# TEST_DUMP_PATH=()
# TEST_LAST_CHILD=()
# TEST_DELETE=()
# TEST_APPEND_MODE=()

# Action test for SKIP requires many steps to confirm proper
# operation.  It is pulled from the regular action tests and
# done its own way.
declare -a TEST_SKIP_SET=(

    # Add progress-tracking mode for "skip" action testing
    after-sibling "test_branch" "skip_test" --
    last-child "skip_test" "progress"       --

    # Jump to start of execution
    pause "About to jump to the start of the TEST_SKIP_SET test." --
    skip begin                          --

    # Each label will only be executed once
    label first                                     --
       skip second "skip_test/progress/did_first"   --
       last-child "skip_test/progress" "did_first"  --
       message "Just done with first"               --
       skip begin                                   --

    label second                                    --
       skip third "skip_test/progress/did_second"   --
       last-child "skip_test/progress" "did_second" --
       message "Just done with second"              --
       skip begin                                   --

    label third                                     --
       skip complete "skip_test/progress/did_third" --
       last-child "skip_test/progress" "did_third"  --
       message "Just done with third"               --
       skip begin                                   --

    label begin --
       # Jump out if completed all steps:
       skip complete "skip_test/progress[did_first][did_second][did_third]" --
       # Otherwise, show message
       message "BEGINNING" --
       pause
       " "
       "Jumping first to the second label, and when returned"
       "from that, start at the top.  The execution order should"
       "be second, first, third."
       --

       skip first "skip_test/progress/did_second" --
       skip second --

    label complete --
    display skip_test --
    pause "All the steps should have been completed to get here." --

    pause "Completed the SKIP test."
)

declare -a LAST_CHILD_BIG_TEST=(
    message
    "<%CLRSCR>"
    "(LAST_CHILD_BIG_TEST)"
    " "
    "Create root mode in empty SRM file.  Then add children, each with"
    "children 'first', 'second', and 'third' with last-child action."
    "Then display results."
    " "
    --

    # Skip if already a root element,
    skip start_test "root" --
    # add root if not skipped
    append-mode "root" --

    label start_test --

    display --
    pause " " "Look at starting position" --

    after-sibling "root" "lctest" --
    last-child "lctest" "first" --
    last-child "lctest" "second" --
    last-child "lctest" "third" --

    message " " --
    display --
    pause " " "Did after-sibling with last-childs to populate" --
    message " " --

    before-sibling "lctest" "lcbefore"             --
    last-child "lcbefore" "first" "second" "third" --

    display --
    message " " "Did before-sibling with last-childs to populate" --
)

declare -a SHORT_TEST_SKIP_SET=(
    message "<%CLRSCR>" "(SHORT_TEST_SKIP_SET)" --

    # Add progress-tracking mode for "skip" action testing
    after-sibling "test_branch" "skip_test"                         --
    last-child "skip_test" "progress"                               --

    message "You should just ahead to see the last message." --

    skip last "skip_test/progress" --

    message "You shouldn't see this message" --

    label last --

    pause "This should be the only message you see." --
)

# Other, non action tests:
declare -a TEST_PATH_EVALUATION=(
    message
    "<%CLRSCR>"
    "(TEST_PATH_EVALUATION)"
    "Testing more complicate SRMPath expressions.  The path expression"
    "is needlessly complicated to test/demonstrate nested predicates."
    --

    display "<%SKIP_COMMENTS>" "household" --

    message "execute:"
    "   after_sibling \"household/person[interests[writing]][gender:female]/gender\" \"household_head : true\""
    --

    after_sibling "household/person[interests[writing]][gender:female]/gender" "household_head : true" --

    message "execute:"
    "   after_sibling \"household/person[interests[running]][gender:female]/gender\" \"household_head : true\""
    --
    after_sibling "household/person[interests[running]][gender:female]/gender" "household_head : true" --

    pause " " --

    message
    " "
    "This was a trick action: there is no person who is both"
    "female and is interested in running.  Only one record was"
    "changed to include the 'household_head' instruction."
    " "
    --

    display "household/person[household_head]" --
)

declare -a TEST_BLANK_LINES=(
    message
    "<%CLRSCR>"
    "Test appropriate line inclusions with adjacent modes with no interveing blank lines."
    display test_no_trailing_blank --
    after_sibling "test_no_trailing_blank/result" "result : 2" --
    message "See what happened after adding result:2 after result:" --
    display test_no_trailing_blank --
    pause
    )

### end of TEST ARRAYS SECTION

# Test for existence and type (array) of $1
name_is_array()
{
    local obj_name="$1"
    local declr=$( declare -p "$obj_name" 2>/dev/null )
    # obj_name must be both found AND declared with declare -a:
    if [ $? -eq 0 ]; then
        if [ "${declr:0:10}" == "declare -a" ]; then
            return 0
        fi
    fi
    return 1
}

# Test for existence and type (function) of $1
name_is_function()
{
    local fname="%2"
    local type=$( LC_ALL=C type -t "$fname" )
    [ "$type" == "function" ]
}

# Used by show_action_test() to parse a path string
get_mode_from_path()
{
    local path="$1"
    local IFS="/"
    local arr=( $( echo "$1" ) )
    echo "${arr[0]}"
    return 0
}

# Seeks an action test array and, if found and not empty,
# prepares the array for use as a demonstration of its
# signature action.
show_action_test()
{
    local name="$1"
    local -a newarr
    array_name="TEST_${name^^}"
    if name_is_array "$array_name"; then
        array_reference="${array_name}[@]"
        local_array=( "${!array_reference}" )
        if [ "${#local_array[@]}" -eq 0 ]; then
            return 0
        elif [ "${local_array[0]}" == "flag" ]; then
            newarr=( "${local_array[@]:3}" )
        else
            local action="${local_array[0]}"
            local path="${local_array[1]}"
            local mode=$( get_mode_from_path "$path" )

            newarr=(
                message
                "<%CLRSCR>"
                "(${array_name})"
                "Testing the output of the '$action' action."
                "Before the change is:"
                --

                display "<%SKIP_COMMENTS>" "$mode" --

                message
                " "
                "The output after applying the following commands:"
                "'${local_array[*]}',"
                --

                "${local_array[@]}" --

                display "<%SKIP_COMMENTS>" "$mode" --

                pause --
            )

        fi

        ./gensfw_srm gensfw_srm_test.srm "${newarr[@]}"
    fi
}

# Checks list of action words against test arrays demonstrations.
# The names are collected of actions without test arrays and
# an message is given to alert the user to their lack.
announce_missing_action_tests()
{
    local -a ACTIONS=( $( ./gensfw_srm --show_actions ) )
    local -a missing=()
    local action array_name
    local -i longest=0

    for action in "${ACTIONS[@]}"; do
        array_name="TEST_${action^^}"
        if ! name_is_array "$array_name"; then
            missing+=( "$action" )
            if [ "${#action}" -gt "$longest" ]; then
                longest="${#action}"
            fi
        fi
    done

    if [ "${#missing[@]}" -gt 0 ]; then
        echo "The following actions are missing test arrays."
        for act in "${missing[@]}"; do
            printf "'%-${longest}s (%s)'\n" "${act}" "TEST_${act^^}"
        done
        echo

        local bogus
        read -p "Continue with other test, y or n? " -i "n" bogus
        if [ "$bogus" == "n" ]; then
            exit 1
        fi
    fi

}

# Get list of action words from the gensfw_srm command and
# runs a test of the action using a test array that should
# be defined for the action.
test_actions()
{
    announce_missing_action_tests
    
    local -a ACTIONS=( $( ./gensfw_srm --show_actions ) )
    local action

    for action in "${ACTIONS[@]}"; do
        show_action_test "$action"
    done
}

test_last_child_big_test()
{
    ./gensfw_srm gensfw_srm_test_empty.srm "${LAST_CHILD_BIG_TEST[@]}"
}

test_skip_set()
{
    ./gensfw_srm gensfw_srm_test.srm "${TEST_SKIP_SET[@]}"
}


test_complicated_path()
{
    ./gensfw_srm gensfw_srm_test.srm "${TEST_PATH_EVALUATION[@]}"
}


test_actions
test_last_child_big_test
test_skip_set
test_complicated_path

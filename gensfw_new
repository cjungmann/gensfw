#!/bin/bash

comargs=(
    --height=300
    --width=600
    --center
    --borders=10
    --title "Generate Schema Framework Documents"
    )

interaction_types=( List Add Read Update Delete Import )
view_flags=( use readonly hidden )
view_prompts=( label )

pagetypes=(
    --list
    --column "Interaction Type":TXT
    "${interaction_types[@]}"
    )


OIFS=$IFS
IFS=$'\a'
COMARGS="${comargs[@]}"
IFS=$OIFS

# These need to match the separators used in parsql
RSEP=$'\a'   # Record SEParator  ( \a == \007 )
FSEP=$'\006' # Field SEParator
VSEP=$':'    # Valuew SEParator

valid_mysql_name()
{
    if [ $# -ne 1 ]; then
        exit 1
    fi

    if [[ "$1" =~ [^A-Za-z0-9_$] ]]; then
        exit 1
    else
        echo "$1"
        exit 0
    fi
}

confirm_dbase_name()
{
    local dbname=$( valid_mysql_name "$1" )

    if [ $? -eq 0 ]; then
        local query="SELECT COUNT(*) FROM SCHEMATA WHERE SCHEMA_NAME='${dbname}'"
        local result=$( mysql information_schema -B -N -e "${query}" )
        if [ $? -eq 0 ] && [ $result -eq 1 ]; then
            echo $dbname
            exit 0
        fi
    fi
    exit 1
}

confirm_table_name()
{
    ## Just validate proper form, the existence of the database should already be confirmed:
    local dbname=$( valid_mysql_name "$1" )
    local tname=$( valid_mysql_name "$2" )

    if [ $? -eq 0 ]; then
        local query="SELECT COUNT(*) FROM TABLES WHERE TABLE_SCHEMA='${dbname}' AND TABLE_NAME='${tname}'"
        local result=$( mysql information_schema -B -N -e "${query}" )
        if [ $? -eq 0 ] && [ $result -eq 1 ]; then
            echo $tname
            exit 0
        fi
    fi
    exit 1
}

column_index_by_name()
{
    target="$1"
    index=0
    for name in "${COLUMNARR_NAMES[@]}"; do
        if [ $name == $target ]; then
            echo "$index"
            exit 0
        fi
        (( index++ ))
    done

    exit 1
}

get_column_names()
{
    local column props val
    for column in "$@"; do
       local IFS="${FSEP}"
       props=( $column )
       IFS="${VSEP}"
       for prop in "${props[@]}"; do
           val=( $prop )
           echo "${val[0]}"
       done
    done
}

save_column_info_into_COLUMNARR_and_COLUMNARR_NAMES()
{
    local query="$1"

    # Use external command to collect info for associative array of column info
    local colinfo=$( ./parsql information_schema "${query}" )

    local IFS="${RSEP}"
    local columns=( $colinfo )

    # Maintain separate index of names to preserve column order established by the query:
    IFS=$'\n'; declare -axg COLUMNARR_NAMES=( $( get_column_names "${columns[0]}" ) )

    declare -Axg COLUMNARR

    local column prop val
    for column in "${columns[@]}"; do
        IFS="${FSEP}"; props=( $column )
        IFS="${VSEP}"
        for prop in "${procs[@]}"; do
            val=( $prop )
            COLUMNARR["${val[0]}"]="${val[1]}"
        done
    done
}

debug_dump_COLUMNARR()
{
    echo "There are ${#COLUMNARR_NAMES[@]} columns:"

    local name
    for name in "${COLUMNARR_NAMES[@]}"; do
        echo "Column '${name}': ${COLUMNARR[$name]}"
    done
}

save_table_rows_into_ROWARR()
{
    local result="${1}"
    local IFS=$'\n'; rows=( $result )

    declare -axg ROWARR;
    IFS=$'\t'
    local row index=0
    for row in "${rows[@]}"; do
        ROWARR[$index]=$( echo "${row}" | tr $'\t' "${FSEP}" )
        (( index++ ))
    done
}

debug_dump_ROWARR()
{
    echo "There are ${#ROWARR[@]} rows in the rows array."
    local row index=0
    for row in "${ROWARR[@]}"; do
        echo "Row ${index}: ${row}"
        (( index++ ))
    done
}

get_table_fields()
{
    local dbname=$( confirm_dbase_name "$1" )
    local -i exval="$?"

    local tname
    if [ "$exval" -eq 0 ]; then
        tname=$( confirm_table_name "$dbname" "$2" )
        exval="$?"
    fi
    if [ $exval -ne 0 ]; then
        echo "dbname = ${dbname}"
        echo "tname = ${tname}"
        exit 1
    fi

    local query="\
SELECT COLUMN_NAME,
       UPPER(DATA_TYPE),
       CHARACTER_MAXIMUM_LENGTH,
       COLUMN_TYPE,
       NULLIF('0',INSTR(EXTRA,'auto_increment')) AS autoinc,
       NULLIF('0',INSTR(COLUMN_KEY,'PRI')) AS prikey,
       NULLIF(IS_NULLABLE,'YES') AS nullable,
       NUMERIC_PRECISION,
       NUMERIC_SCALE,
       COLUMN_DEFAULT
  FROM COLUMNS
 WHERE TABLE_SCHEMA='${dbname}' AND TABLE_NAME='${tname}'"

    local result=$( mysql information_schema -B -N -e "${query}" )
    if [ $? -ne 0 ]; then
        echo "Query failed! ($?) for query;"
        echo "${query}"
        exit 1
    fi

    save_column_info_into_COLUMNARR_and_COLUMNARR_NAMES "${query}"
    save_table_rows_into_ROWARR "${result}"
}

make_default_interaction_array()
{
    local type="$1"
    local fname flag ndx_name

    ndx_name=$( column_index_by_name "name" )
    exval=$?
    if [ $exval -ne 0 ]; then
        echo "Failed to column_index_by_name (${exval}): DEBUG_DUMP:"
        debug_dump_COLUMNARR
        exit 1
    fi

    local IFS="${FSEP}"
    for row in "${ROWARR[@]}"; do
        rowarr=( $row )
        fname="${rowarr[$ndx_name]}"
        echo "${fname}"
        for flag in "${view_flags[@]}"; do
            echo "true"
        done
    done
}

make_interaction_arrays()
{
    local IFS=$' \n\t'

    local itype
    for itype in "${interaction_types[@]}"; do
        echo "itype is '${itype}'"
        IFS=$' \n\t'; arr=( $( make_default_interaction_array "${itype}" ) )
        IFS="${VSEP}"; line="${arr[@]}"
        echo "line is '$line'"
    done
}


process_table_itype()
{
    local dbname="$1"
    local tname="$2"
    local itype="$3"

    local options
    options=$(echo "${xml_table_schema}" |  xsltproc --stringparam itype "${itype}"  fields.xsl - )
    echo yad "${options}"
}

process_table()
{
    local dbname=$( valid_mysql_name $1 )
    local -i exval="$?"
    local tname
    if [ $exval -eq 0 ]; then
        tname=$( valid_mysql_name $2 )
        exval="$?"
    fi

    if [ $exval -ne 0 ]; then
        local ename
        if [ -n $tname ]; then
            ename="$tname"
        else
            ename="$dbname"
        fi
        echo "'$ename' is an invalid MySQL name is exval='${exval}'"
        exit $exval
    fi

    get_table_fields "$dbname" "$tname"
    if [ $? -ne 0 ]; then
        echo "get_table_fields returned a $?"
        echo "coldata = ${coldata}"
        exit 1
    fi

    # debug_dump_COLUMNARR
    # debug_dump_ROWARR

    vals=$( make_interaction_arrays )

    local text="\
Create default MySQL procedure and SRM scripts for

    Database: $dbname
       Table: $tname"

    declare -x xml_table_schema=$( xmlify -t $tname $dbname )

    local result
    while true; do
        result=$( yad "${comargs[@]}" "${pagetypes[@]}" --text "${text}" )
        exval="$?"
        case $exval in
            1|252) break;;
            *)
                echo "exit value was $exval"
                process_table_itype $dbname $tname $result
                ;;
        esac
    done

    unset xml_table_schema
}

# This general purpose function is used by get_database_name
# and get_table_name to collect selections from the user.
pick_from_list()
{
    local largs=(
        --text "Select a $1 from the following list:"
        --list
        --column "$1":TEXT
    )

    local result
    result=$(yad "${comargs[@]}" "${largs[@]}" "${@:2}")
    local -i exval=$?

    if [ $exval -eq 0 ]; then
        echo "${result:0: -1}"
    fi
    exit $exval
}

get_database_name()
{
    local dbnames dbname
    dbnames=( $(mysql -B -N -e show\ databases) )
    local -i exval=$?
    if [ $exval -ne 0 ]; then
        echo "Failed to get database names from MySQL"
        exit $exval
    fi

    dbname=$( pick_from_list "database name" "${dbnames[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        echo "${dbname}"
    fi
    exit $exval
}

get_table_name()
{
    local tnames tname
    local dbname="$1"
    tnames=( $(mysql -B -N "$dbname" -e show\ tables) )
    local -i exval=$?
    if [ $exval -ne 0 ]; then
        echo "Failed to get MySQL table names from '$dbname'"
        exit "$exval"
    fi

    tname=$( pick_from_list "table from $1" "${tnames[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        echo "${tname}"
    fi
    exit $exval
}



# Start execution here, starting with confirming the parameters,
# then launching into the database and table selections.
arg_count=$#
if [ $arg_count -gt 0 ]; then
    p_dbasename=$( valid_mysql_name "$1" )
    if [ $? -ne 0 ]; then
        echo "Bad database name"
        exit 1
    fi
fi

if [ $arg_count -gt 1 ]; then
    p_tablename=$( valid_mysql_name "$2" )
    if [ $? -ne 0 ]; then
        echo "Bad table name"
        exit 1
    fi
fi

loop_dbases=true
while $loop_dbases; do
    if [ $arg_count -eq 0 ]; then
        dbname=$( get_database_name )
        exval=$?
        if [ $exval -ne 0 ]; then
            loop_dbases=false
            break
        fi
    else
        dbname=$p_dbasename
        loop_dbases=false
    fi

    loop_tables=true;
    while $loop_tables; do
        if [ $arg_count -lt 2 ]; then
            tname=$( get_table_name $dbname )
            if [ $? -ne 0 ]; then
                loop_tables=false
                break
            fi
        else
            tname=$p_tablename
            loop_tables=false
        fi

        process_table "$dbname" "$tname"
    done
done

#!/bin/bash

# These need to match the separators used in parsql
RSEP=$'\a'   # Record SEParator  ( \a == \007 )
FSEP=$'\006' # Field SEParator
VSEP=$':'    # Valuew SEParator

# Generic array separator for adhoc use
ASEP=$'\a'   # Array SEParator, common array separator for returning and restoring arrays

comargs=(
    --height=400
    --width=600
    --center
    --borders=10
    --title "Generate Schema Framework Documents"
    )

interaction_types=( List Add Read Update Delete Import )
view_flags=( use readonly hidden )
view_prompts=( label )

pagetypes=(
    --list
    --column "Interaction Type":TXT
    "${interaction_types[@]}"
    )

OIFS=$IFS
IFS=$'\a'
COMARGS="${comargs[@]}"
IFS=$OIFS

# These global names will be used to access the properties of a result row
declare -a META_COLUMN_NAMES
declare -a META_COLUMNS

declare -A RECORD_COLUMN_NAMES
declare -A RESULT_ROW_NAMES_MAP
declare -a RESULT_ROW_NAMES_ORDERED

# This global name provides access to rows of a query
declare -a RECORD_ROWS

validate_mysql_name()
{
    if [ $# -ne 1 ]; then
        exit 1
    fi

    if [[ "$1" =~ [^A-Za-z0-9_$] ]]; then
        exit 1
    else
        echo "$1"
        exit 0
    fi
}

confirm_dbase_name()
{
    local dbname=$( validate_mysql_name "$1" )

    if [ $? -eq 0 ]; then
        local query="SELECT COUNT(*) FROM SCHEMATA WHERE SCHEMA_NAME='${dbname}'"
        local result=$( mysql information_schema -B -N -e "${query}" )
        if [ $? -eq 0 ] && [ $result -eq 1 ]; then
            echo $dbname
            exit 0
        fi
    fi
    exit 1
}

confirm_table_name()
{
    ## Just validate proper form, the existence of the database should already be confirmed:
    local dbname=$( validate_mysql_name "$1" )
    local tname=$( validate_mysql_name "$2" )

    if [ $? -eq 0 ]; then
        local query="SELECT COUNT(*) FROM TABLES WHERE TABLE_SCHEMA='${dbname}' AND TABLE_NAME='${tname}'"
        local result=$( mysql information_schema -B -N -e "${query}" )
        if [ $? -eq 0 ] && [ $result -eq 1 ]; then
            echo $tname
            exit 0
        fi
    fi
    exit 1
}



debug_dump_row_by_column_index()
{
    local ndx=$1
    local rawrow row
    local IFS="${FSEP}"
    local -i index=0
    for rawrow in "${RECORD_ROWS[@]}"; do
        row=( $rawrow )
        echo "col $index: ${row[$nd]}" >&2
        (( index++ ))
    done
}

# Returns the index to an array element that matches a target value
# Usage:
# array_index_by_value [target] "${arr[@]}"
#
# Where target is the string to be found, and an expansion of the target
# array expansion follows.  The function can search the parameters for
# the target, setting the exit status to indicate success or failure,
# and echoing the index value upon success.
array_index_by_value()
{
    local target="$1"

    local index=0
    for el in "${@:2}"; do
        if [ "$el" == "$target" ]; then
            echo "$index"
            exit 0
        fi
        (( index++ ))
    done
    exit 1
}

row_index_by_name()
{
    local target="$1"
    local meta_index=0
    local name
    for name in "${META_COLUMN_NAMES[@]}"; do
        if [ $name == $target ]; then
            break;
        fi
        (( meta_index++ ))
    done

    local rowindex rawrow row
    rowindex=0
    local IFS="${FSEP}"
    for rawrow in "${RECORD_ROWS[@]}"; do
        row=( ${rawrow} )
        if [ "${row[$meta_index]}" == $target ]; then
            return ${rowindex}
            exit 0
        fi
        (( ++rowindex ))
    done

    debug_dump_row_by_column_index $meta_index
    exit 1
}

get_column_names()
{
    local column props val
    for column in "$@"; do
       local IFS="${FSEP}"
       props=( $column )
       IFS="${VSEP}"
       for prop in "${props[@]}"; do
           val=( $prop )
           echo "${val[0]}"
       done
    done
}

get_prop_list_from_column_element()
{
    local column="$1"
    local val prop
    local -a props

    local IFS="${FSEP}"
    props=( $( echo "$column" ) )

    for prop in "${props[@]}"; do
        IFS="${VSEP}"
        val=( $prop )
        if [ $val[0] ]; then
            printf "%s${FSEP}" "${val[1]}"
        fi
    done
}

save_column_info_into_META_COLUMNS_and_META_COLUMN_NAMES()
{
    local query="$1"

    # Use external command to collect info for associative array of column info
    local colinfo=$( ./parsql information_schema "${query}" )

    local IFS="${RSEP}"
    local columns=( $colinfo )

    # Maintain separate index of names to preserve column order established by the query:
    IFS=$'\n'; declare -axg META_COLUMN_NAMES=( $( get_column_names "${columns[0]}" ) )

    declare -axg META_COLUMNS

    local column proplist
    local -i index=0

    for column in "${columns[@]}"; do
        proplist=$( get_prop_list_from_column_element "${column}" )
        if [ $? ]; then
            META_COLUMNS[$index]=$( get_prop_list_from_column_element "${column}" )
            (( index++ ))
        fi
        
    done
}

make_RECORD_COLUMN_NAMES_from_META_COLUMNS()
{
    RECORD_COLUMN_NAMES=()
    local -i index=0
    local -i ndxName="${RESULT_ROW_NAMES_MAP['Name']}"
    local -a props
    local name
    local IFS="${FSEP}"
    for meta_column in "${META_COLUMNS[@]}"; do
        props=( $meta_column )
        name="${props[$ndxName]}"
        RECORD_COLUMN_NAMES[$name]=$index
        (( index++ ))
    done
}

save_table_rows_into_RECORD_ROWS()
{
    local result="${1}"
    local IFS=$'\n'; rows=( $result )

    declare -axg RECORD_ROWS;
    IFS=$'\t'
    local row index=0
    for row in "${rows[@]}"; do
        RECORD_ROWS[$index]=$( echo "${row}" | tr $'\t' "${FSEP}" )
        (( index++ ))
    done
}

make_RESULT_ROW_NAMES_MAP_from_RECORD_ROWS()
{
    RESULT_ROW_NAMES_MAP=()
    local -i ndxNameCol="${RECORD_COLUMN_NAMES['Name']}"
    local row props name
    local -i ndxRow=0
    for row in "${RECORD_ROWS[@]}"; do
        local IFS="${FSEP}"
        props=( $row )
        name="${props[$ndxNameCol]}"
        RESULT_ROW_NAMES_MAP["${name}"]=$ndxRow
        (( ndxRow++ ))
    done
}


make_RESULT_ROW_NAMES_ORDERED_from_RECORD_ROWS()
{
    RESULT_ROW_NAMES_ORDERED=()
    local -i ndxNameCol="${RECORD_COLUMN_NAMES['Name']}"
    local row props name
    local -i ndxRow=0
    for row in "${RECORD_ROWS[@]}"; do
        local IFS="${FSEP}"
        props=( $row )
        name="${props[$ndxNameCol]}"
        RESULT_ROW_NAMES_ORDERED[$ndxRow]="${name}"
        (( ndxRow++ ))
    done
}


collect_table_fields()
{
    local dbname=$( confirm_dbase_name "$1" )
    local -i exval="$?"

    local tname
    if [ "$exval" -eq 0 ]; then
        tname=$( confirm_table_name "$dbname" "$2" )
        exval="$?"
    fi
    if [ $exval -ne 0 ]; then
        echo "dbname = ${dbname}"
        echo "tname = ${tname}"
        exit 1
    fi

    local query="\
SELECT COLUMN_NAME,
       UPPER(DATA_TYPE) AS DATA_TYPE,
       CHARACTER_MAXIMUM_LENGTH,
       COLUMN_TYPE,
       NULLIF('0',INSTR(EXTRA,'auto_increment')) AS autoinc,
       NULLIF('0',INSTR(COLUMN_KEY,'PRI')) AS prikey,
       NULLIF(IS_NULLABLE,'YES') AS nullable,
       NUMERIC_PRECISION,
       NUMERIC_SCALE,
       COLUMN_DEFAULT
  FROM COLUMNS
 WHERE TABLE_SCHEMA='${dbname}' AND TABLE_NAME='${tname}'"

    local result=$( mysql information_schema -B -N -e "${query}" )
    if [ $? -ne 0 ]; then
        echo "Query failed! ($?) for query;"
        echo "${query}"
        exit 1
    fi

    save_column_info_into_META_COLUMNS_and_META_COLUMN_NAMES "${query}"
    make_RECORD_COLUMN_NAMES_from_META_COLUMNS
    save_table_rows_into_RECORD_ROWS "${result}"
    make_RESULT_ROW_NAMES_ORDERED_from_RECORD_ROWS
    make_RESULT_ROW_NAMES_MAP_from_RECORD_ROWS

    # echo "META_COLUMNS:"
    # printf "%s\n" "${META_COLUMNS[@]}"
    # echo
    # echo "META_COLUMN_NAMES:"
    # printf "%s\n" "${META_COLUMN_NAMES[@]}"

    # echo "RESULT_ROW_NAMES_MAP:"
    # printf "%s\n" "${!RESULT_ROW_NAMES_MAP[@]}"
    # echo "RESULT_ROW_NAMES_ORDERED:"
    # printf "%s\n" "${RESULT_ROW_NAMES_ORDERED[@]}"
}

make_default_interaction_array()
{
    local type="$1"
    local fname flag ndx_name

    # ndx_name=$( row_index_by_name "name" )
    ndx_name="${RESULT_ROW_NAMES_MAP['Name']}"
    exval=$?
    if [ $exval -ne 0 ]; then
        echo "Failed to row_index_by_name (${exval}): DEBUG_DUMP:"
        exit 1
    fi

    local IFS="${FSEP}"
    for row in "${RECORD_ROWS[@]}"; do
        rowarr=( $row )
        fname="${rowarr[$ndx_name]}"
        echo "${fname}"
        for flag in "${view_flags[@]}"; do
            echo "true"
        done
    done
}

make_interaction_arrays()
{
    local IFS=$' \n\t'

    local itype
    for itype in "${interaction_types[@]}"; do
        echo "itype is '${itype}'"
        IFS=$' \n\t'; arr=( $( make_default_interaction_array "${itype}" ) )
        IFS="${VSEP}"; line="${arr[@]}"
        echo "line is '$line'"
    done
}

get_list_options_array_string()
{
    local options=(
        --list
        --always-print-result
        --print-all
        --editable
        --editable-cols 5
        --column "Name":TEXT
        --column "Use":CHK
        --column "Hide":CHK
        --column "Disable":CHK
        --column "Label"
    )

    local IFS="$1"
    echo -n "${options[*]}"
}


prepare_default_list_values()
{
    local ASEP="$1"
    local itype="$2"

    local ndxName="${RECORD_COLUMN_NAMES['COLUMN_NAME']}"
    local ndxPriKey="${RECORD_COLUMN_NAMES['prikey']}"
    local ndxDefault="${RECORD_COLUMN_NAMES['COLUMN_DEFAULT']}"

    local -a valsarr=(name true false false)
    valsarr[4]=

    local currow rowvals
    local IFS="${FSEP}"

    for currow in "${RECORD_ROWS[@]}"; do
        IFS="${FSEP}"
        rowvals=( $currow )

        valsarr[0]="${rowvals[$ndxName]}"

        IFS="${ASEP}"
        echo -n "${valsarr[*]}" "${IFS}"
    done
}


process_table_itype()
{
    local dbname="$1"
    local tname="$2"
    local itype="$3"

    local IFS="${ASEP}"
    local -a list_options=( $( get_list_options_array_string "${ASEP}" ) )
    local -a list_values=( $( prepare_default_list_values "${ASEP}" "${itype}" ) )

    local result

    result=$( yad "${comargs[@]}" "${list_options[@]}" "${list_values[@]}" )
    echo "result is ${result}"
}

collect_table_information()
{
    local dbname=$( validate_mysql_name $1 )
    local -i exval="$?"
    local tname
    if [ $exval -eq 0 ]; then
        tname=$( validate_mysql_name $2 )
        exval="$?"
    fi

    if [ $exval -ne 0 ]; then
        local ename
        if [ -n $tname ]; then
            ename="$tname"
        else
            ename="$dbname"
        fi
        echo "'$ename' is an invalid MySQL name is exval='${exval}'"
        exit $exval
    fi

    collect_table_fields "$dbname" "$tname"
    if [ $? -ne 0 ]; then
        echo "collect_table_fields returned a $?"
        echo "coldata = ${coldata}"
        exit 1
    fi
}

process_table()
{
    # Accept dbname and tname values, they've been validated by now
    local dbname="$1"
    local tname="$2"

    vals=$( make_interaction_arrays )

    tabarr=$( make_table_array "$dbname" "$tname" )

    local text="\
Create default MySQL procedure and SRM scripts for

    Database: $dbname
       Table: $tname"

    declare -x xml_table_schema=$( xmlify -t $tname $dbname )

    local result
    while true; do
        local IFS=$'\n'
        result=$( yad "${comargs[@]}" "${pagetypes[@]}" --text "${text}" )
        exval="$?"
        case $exval in
            1|252) break;;
            *)
                process_table_itype $dbname $tname $result
                ;;
        esac
    done

    unset xml_table_schema
}

# This general purpose function is used by dialog_pick_database
# and dialog_pick_table to collect selections from the user.
yad_pick_from_list()
{
    local largs=(
        --text "Select a $1 from the following list:"
        --list
        --column "$1":TEXT
    )

    local result
    result=$(yad "${comargs[@]}" "${largs[@]}" "${@:2}")
    local -i exval=$?

    if [ $exval -eq 0 ]; then
        echo "${result:0: -1}"
    fi
    exit $exval
}

dialog_pick_database()
{
    local dbnames dbname
    dbnames=( $(mysql -B -N -e show\ databases) )
    local -i exval=$?
    if [ $exval -ne 0 ]; then
        echo "Failed to get database names from MySQL"
        exit $exval
    fi

    dbname=$( yad_pick_from_list "database name" "${dbnames[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        echo "${dbname}"
    fi
    exit $exval
}

dialog_pick_table()
{
    local tnames tname
    local dbname="$1"
    tnames=( $(mysql -B -N "$dbname" -e show\ tables) )
    local -i exval=$?
    if [ $exval -ne 0 ]; then
        echo "Failed to get MySQL table names from '$dbname'"
        exit "$exval"
    fi

    tname=$( yad_pick_from_list "table from $1" "${tnames[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        echo "${tname}"
    fi
    exit $exval
}

# Start execution here, starting with confirming the parameters,
# then launching into the database and table selections.
arg_count=$#
if [ $arg_count -gt 0 ]; then
    p_dbasename=$( validate_mysql_name "$1" )
    if [ $? -ne 0 ]; then
        echo "Bad database name"
        exit 1
    fi
fi

if [ $arg_count -gt 1 ]; then
    p_tablename=$( validate_mysql_name "$2" )
    if [ $? -ne 0 ]; then
        echo "Bad table name"
        exit 1
    fi
fi

loop_dbases=true
while $loop_dbases; do
    if [ $arg_count -eq 0 ]; then
        dbname=$( dialog_pick_database )
        exval=$?
        if [ $exval -ne 0 ]; then
            loop_dbases=false
            break
        fi
    else
        dbname=$p_dbasename
        loop_dbases=false
    fi

    loop_tables=true;
    while $loop_tables; do
        if [ $arg_count -lt 2 ]; then
            tname=$( dialog_pick_table $dbname )
            if [ $? -ne 0 ]; then
                loop_tables=false
                break
            fi
        else
            tname=$p_tablename
            loop_tables=false
        fi

        collect_table_information "$dbname" "$tname"

        if [ $? -eq 0 ]; then
            process_table "$dbname" "$tname"
        else
            echo "Unexpected column name suggests changed query.  Please check."
        fi
    done
done

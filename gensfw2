#!/bin/bash

# Primary Dialogs in this application (many dialogs have sub-dialogs):
# 1: Select Database from List (or open GSF file)
# 2: Select Table from List (or open GSF file)
# 3: Edit Table Preferences Dialog, can start dialogs 4, 5, and 6
# 4: Edit Interaction Preferences Dialog
# 5: Set Default Column Labels
# 6: Save Files Dialog

source gensfw2_bacts
source gensfw2_scripts_sql

# One or the other of the following, either override
# default SEPS (first line), or get the default SEPS
# values from bashmysql:
SEPS='@#$'
# SEPS=$( bashmysql -S )

RSEP="${SEPS:0:1}"
FSEP="${SEPS:1:1}"
VSEP="${SEPS:2:1}"

YSEP="${FSEP}"
YSEP='^'

declare -a IACT_NAMES=( List Add Read Update Delete Import )
declare -a IACT_COLUMNS=( Type Param Result Readonly Hide Label )

declare -gi G_PLUG_NUM=$$ ## Commence plug numbers from process id

# COL_xxxx integers are indexes to column for result of COLS_QUERY
# These will not change once set
declare -gi COL_NAME
declare -gi COL_TYPE
declare -gi COL_PRIKEY
declare -gi COL_DEFAULT

# The list of available database won't change (unless we change hosts):
declare -a DBASE_NAMES=( $( mysql -BN -e "show databases" ) ) 

# The next two variables can be either set from command line,
# from dialogs 1 and 2, or by opening a settings file:
declare -gx GF_DBNAME
declare -gx GF_TNAME

# 
declare -gx GF_FILE_ARG
declare -gx GF_FILEPATH_GSF
declare -gx GF_FILEPATH_SQL
declare -gx GF_FILEPATH_SRM

# This array changes when GF_DBNAME changes (from Dialog 1):
declare -a TABLE_NAMES

declare -a GSF_FIELD_NAMES  # Initialized when a table is selected
declare -a GSF_FIELD_LABELS # From settings file or by using Dialog 5 (default labels)

declare -a IACT_FIELD_LABELS
declare -A IACT_DATA

# Clear variables that might retain info from previous table:
reset_for_new_table()
{
    GF_FILEPATH_GSF=
    GF_FILEPATH_SQL=
    GF_FILEPATH_SRM=
    GSF_FIELD_NAMES=()
    GSF_FIELD_LABELS=()
}

set_file_path_defaults()
{
    local IFS="/"
    local lpath fname froot
    local -a tarr farr=( $( echo "$1" ) )
    local -i tlen flen="${#farr[@]}"
    if [ $flen -eq 1 ]; then
        fname="$1"
        lpath=""
    else
        tarr=( "${farr[@]:0:$(( flen-1 ))}" )
        lpath="${tarr[*]}"
        fname="${farr[ $(( flen-1 )) ]}"
    fi


    IFS="\."
    tarr=( $( echo "${fname}" ) )
    tlen="${#tarr[@]}"
    if [ $tlen -eq 0 ]; then
        froot="${fname}"
    else
        froot="${tarr[*]:0:$(( tlen-1 ))}"
    fi
    froot="${tarr[@]:0:$(( tlen-1 ))}"

    local fbase="${froot}"
    if [ -n "${lpath}" ]; then
        fbase="${lpath}/${froot}"
    fi
    GF_FILEPATH_GSF="$1"
    GF_FILEPATH_SQL="${fbase}.sql"
    GF_FILEPATH_SRM="${fbase}.srm"
}

# Convenient function to avoid having to know the array name:
get_fields_count() { echo "${#GSF_FIELD_NAMES[@]}"; }

# All primary yad dialogs should use this
# (Not paned or notebook plugs):
declare -a YAD_COMMON_ARGS=(
    --height 500
    --width 750
    --center
    --borders 10
    --separator "${YSEP}"
    --title "Generate Schema Framework Scripts"
)


### Dialog #3: Table Preferences Dialog ###
### Usde in function: show_table_preferences_dialog()
# Primary yad dialog, for current dbase/table
# - Select interaction types to edit
# - Set default column labels
# - Save script and settings files
declare -a TABLE_PREFERENCES_DIALOG=(
    "${YAD_COMMON_ARGS[@]}"
    --paned
    --tab "Tab1"
    --tab "Tab2"
    --button "Set _Labels":3
    --button "Save _Files":2
    --button "Cancel":1
    --button "_OK":0
    )

# Dialog #3 top pane, call start_table_preferences_meta_pane()

# Dialog #3, bottom pane, before adding data:
declare -a IACT_TYPES_LIST=(
    --text "Click on an interaction type to set column preferences."
    --list
    --separator "${YSEP}"
    --column "Interaction Type":TEXT
)


### Dialog #4: Interaction Settings Dialog
### Use in function: show_interaction_preferences_dialog()
# Primary yad dialog, set column preferences for the interaction.
declare -a INTERACTION_PREFERENCES_DIALOG=(
    --paned
    --tab="Tab1"
    --tab="Tab2"
    --button "Show S_RM":3
    --button "Show S_QL":2
    --button "Cancel":1
    --button "_Ok":0
    )

# Dialog #4 top pane, before data added:
declare -a IACT_TOP_PANE=(
    --tabnum=1
    --form
    --separator "${YSEP}"
    --field "Interaction":RO
    --field "Include":CHK
    )


# Dialog #4 bottom pane, before data added:
declare -a IACT_LIST_PANE=(
    --tabnum=2
    --list
    --always-print-result
    --separator "${YSEP}"
    --print-all
    --editable
    --editable-cols 6
    --column "Column Name":TEXT
    --column "Type":TEXT
    --column "Param":CHK
    --column "Result":CHK
    --column "Readonly":CHK
    --column "Hide":CHK
    --column "Label":TEXT
)

# Set every interaction type values to not included."
reset_IACT_DATA()
{
    IACT_DATA=()
    local name
    for name in "${IACT_NAMES[@]}"; do
        IACT_DATA[$name]="FALSE"
    done
}
# Intialize for first use:
reset_IACT_DATA


declare COLS_QUERY="\
SELECT COLUMN_NAME,
       UPPER(DATA_TYPE) AS DATA_TYPE,
       CHARACTER_MAXIMUM_LENGTH,
       COLUMN_TYPE,
       CASE WHEN INSTR(EXTRA,'auto_increment') THEN 'YES' ELSE NULL END AS autoinc,
       CASE WHEN INSTR(COLUMN_KEY,'PRI') THEN 'YES' ELSE NULL END AS prikey,
       NULLIF(IS_NULLABLE,'NO') AS nullable,
       NUMERIC_PRECISION,
       NUMERIC_SCALE,
       COLUMN_DEFAULT
  FROM COLUMNS"


# gsf_callback_prefs_rows()
# Scans and expands preferences data into arrays, which are made 
# accessible through a callback function.
# 
# This function is designed to be called from the script-writing options
# of Dialog #4, from which the IACT_COL_PREFS array is instantiated from
# the results of a column preferences page.  That said, the same array
# could be instantiated in other contexts, in particular, in processing
# an entire GSF settings file by creating an IACT_COL_PREFS array from
# each interaction record.
gsf_callback_prefs_rows()
{
    local callback="$1"
    local IFS="${YSEP}"
    local -t CALLBACK_ROW
    local rowstr
    for rowstr in "${IACT_COL_PREFS[@]}"; do
        CALLBACK_ROW=( $( echo "${rowstr}" ) )
        if [ "${#CALLBACK_ROW[@]}" -gt 2 ]; then
            $callback
        fi
    done
}

# These simple functions interpret the callback data from function
# gsf_callback_prefs_rows().
CB_ROW_IS_PARAM() { [ "${CALLBACK_ROW[2]}"="TRUE" ]; return $?; }
CB_ROW_IS_INDEX() { table_field_is_index "${CALLBACK_ROW[0]}"; return $?; }

# Universal script indentation string
declare gsf_script_indent="  "

# Save column indexes to global variables for repeated access
collect_column_indexes()
{
    declare -i ndx
    declare -i exval=0

    # Use nested function to reuse repeated code.
    # First failure to find skips the rest.
    get_index()
    {
        if [ $exval -eq 0 ]; then
            ndx=$( find_column_index "$1" )
            exval=$?
            if [ $exval -ne 0 ]; then
                echo "Can't find column '$1'." >&2
                exit $exval
            fi
        fi
    }

    get_index "COLUMN_NAME";    COL_NAME=$ndx
    get_index "DATA_TYPE";      COL_TYPE=$ndx
    get_index "prikey";         COL_PRIKEY=$ndx
    get_index "COLUMN_DEFAULT"; COL_DEFAULT=$ndx
}

# Get field names from global table information
update_field_names_array()
{
    GSF_FIELD_NAMES=()

    declare rowstr
    declare -a row
    declare -i ndx=0
    local IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "${rowstr}" ) ) 
        GSF_FIELD_NAMES[$ndx]="${row[$COL_NAME]}"
        GSF_FIELD_LABELS[$ndx]=""
        (( ndx++ ))
    done
}

get_iact_meta_vals_str()
{
    local -i exval
    local itype="$1"
    local metastr

    metastr="${IACT_DATA[$itype]}"

    exval=$?
    if [ $exval -ne 0 ]; then
        echo "Error retrieving data for the '${itype}' interaction." >&2
        exit $exval
    fi

    local -a savedvals
    local IFS="${FSEP}"
    savedvals=( $( echo "$metastr" ) )
    echo "${itype}${YSEP}${savedvals[0]}"
}

# get_iact_list_data_str()
# This function unpacks the data that was compiled by
# save_iact_choices().
get_iact_list_data_str()
{
    local itype="$1"
    local IFS

    # First check if the interaction type has a saved value:
    local -i exval
    local -a fields
    local -a vals ovals
    local valstr="${IACT_DATA[$itype]}"
    exval=$?
    if [ $exval -eq 0 ]; then
        IFS="${FSEP}"
        fields=( $( echo "${valstr}" ) )
        exval=$?
        if [ $exval -eq 0 -a "${#fields[@]}" -gt 1 ]; then
            for fieldstr in "${fields[@]}"; do
                IFS="${YSEP}"
                vals=( $( echo "${fieldstr}" ) )
                if [ ${#vals[@]} -gt 1 ]; then
                    echo -n "${vals[*]}${YSEP}"
                fi
            done
            return 0
        fi
    fi

    # If no saved value, return a default string to start with:
    local rowstr
    local -a row
    local -i is_index

    # Reset IFS to parse fields from rowstr from bashmysql:
    IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "$rowstr") )

        is_index=$( [ -n "${row[$COL_PRIKEY]}" ]; echo $? )

        # Skip field if not a new record:
        if [[ $is_index -eq 0 && " Add Import " =~ "${itype}" ]]; then
            continue
        fi

        # Information/Identification column (name and datatype)
        echo -n "${row[COL_NAME]}${YSEP}${row[COL_TYPE]}"

        # The Param and Result columns a flags to include the field
        # in the respective domain.  Fields for which the Param flag
        # is set will be include the field in the parameter list.
        # Likewise, fields for which the Result flag will be included
        # in the results by adding the field to the  SELECT clause
        # of the query.

        # Param column, FALSE for List, Read, and Delete, TRUE otherwise
        local param_false=" List Read Delete "
        if [[ $is_index -ne 0 && " List Read Delete " =~ " ${itype} " ]]; then
            echo -n "${YSEP}FALSE"
        else
            echo -n "${YSEP}TRUE"
        fi

        # Result column, TRUE for List, Read, otherwise FALSE
        if [ $itype = "List" -o $itype = "Read" ]; then
            echo -n "${YSEP}TRUE"
        else
            echo -n "${YSEP}FALSE"
        fi

        # Readonly and Hide (For index fields)
        if [ $is_index -eq 0 ]; then
            echo -n "${YSEP}TRUE${YSEP}TRUE"
        else
            echo -n "${YSEP}FALSE${YSEP}FALSE"
        fi

        # Blank element for the label
        echo -n "${YSEP}"
        echo -n "${YSEP}"

    done
}

# make_iact_choices_string()
# Converts result of dialog #4 to a string with table fields
# separated by FSEP and the field preferences separated by YSEP.
make_iact_choices_string()
{
    local IFS
    local line
    local -a lines choices row

    # These are used to set and build a record value:
    local iact_name
    local iact_incl
    local -a iact_frows

    # First split to rows:
    IFS=$'\n'
    lines=( $(echo "$1" ) )

    for line in "${lines[@]}"; do
        IFS="${YSEP}"
        row=( $( echo "${line}" ) )
        if [ "${#row[@]}" -lt 4 ]; then
            iact_name="${row[0]}"
            iact_incl="${row[1]}"
        else
            IFS="${YSEP}"

            # Add extra YSEP in case of empty final field:
            rowstr="${row[*]}${YSEP}"

            IFS="${FSEP}"
            iact_frows=( "${iact_frows[@]}" "${rowstr}" )
        fi
    done

    IFS="${FSEP}"
    echo -n "${iact_incl}${FSEP}${iact_frows[*]}"
}

# save_iact_choices():
# Saves the result of make_iact_choices_string() to IACT_DATA
# to reopen and to serialize to disk.
save_iact_choices()
{
    local -i exval
    local choices
    choices_str=$( make_iact_choices_string "$1" )
    exval=$?
    if [ $exval -eq 0 ]; then
        IACT_DATA[$IACT_NAME]="$choices_str"
    fi
}

index_in_array()
{
    local target="$1"
    local el
    local -i ndx=0
    for el in "${@:2}"; do
        if [ "$el" = "$target" ]; then
            echo "$ndx"
            return 0
        fi
        (( ndx++ ))
    done
    return 1
}

string_in_array()
{
    local target="$1"
    local el
    for el in "${@:2}"; do
        if [ "$el" = "$target" ]; then
            return 0
        fi
    done
    return 1
}

confirm_dbase_name() { string_in_array "${GF_DBNAME}" "${DBASE_NAMES[@]}"; }
confirm_table_name() { string_in_array "${GF_TNAME}" "${TABLE_NAMES[@]}"; }
confirm_iact_name()  { string_in_array "$1" "${IACT_NAMES[@]}"; }

set_dbase_name()
{
    GF_TNAME=
    TABLE_NAMES=()
    if string_in_array "$1" "${DBASE_NAMES[@]}" ; then
        GF_DBNAME="$1"
        local IFS=$'\n'
        TABLE_NAMES=( $( mysql "${GF_DBNAME}" -BN -e "show tables" ) )
    else
        echo "'$1' is not a database name on this server." >&2
        exit 1
    fi
}

set_table_name()
{
    if string_in_array "$1" "${TABLE_NAMES[@]}"; then
        GF_TNAME="$1"
    else
        echo "'$1' is not a table name in the ${GF_DBNAME} database." >&2
        exit 1
    fi
}


# This function can terminate the script with an unknown database
# or table name.  Thus, there is no return value for this function.
parse_args()
{
    local arg
    for arg in "$@"; do
        if [ -f "${arg}" ]; then
            GF_FILE_ARG="${arg}"
            set_file_path_defaults "${arg}"
            gsf_read_settings_from_file "${GF_FILEPATH_GSF}"
            break
        elif [ -z "$GF_DBNAME" ]; then
            set_dbase_name "$arg"
        elif [ -z "$GF_TNAME" ]; then
            set_table_name "$arg"
        fi
    done
}

# Using the first character of IFS as the separator, this function creates a
# string of values from a specified column of a list result.
#
# For example, local -a arr=( $( array_str_from_list_result 1 "$result" ) )
# will make an array from the second column of the list result.
array_str_from_list_result()
{
    local -a lines vals
    local line
    local -i col="$1"

    # Save IFS character before we change IFS
    local VSEP="${IFS:0:1}"

    # List results separated by newlines:
    local IFS=$'\n'
    lines=( $( echo "$2" ) )

    # Set IFS to split each line into values:
    IFS="${YSEP}"
    for line in "${lines[@]}"; do
        vals=( $( echo "$line" ) )
        # Echo each value, followed by the VSEP value we saved above:
        echo -n "${vals[$col]}${VSEP}"
    done
}

# split_yad_arrs()
# Used in dialog #4 (show_interaction_preferences_dialog()) to split
# an array of YAD arrays into a single array.  Use the output of to
# create a new array for submission to YAD.
split_yad_arrs()
{
    local LSEP="${IFS:0:1}"
    local IFS="${YSEP}"
    local str el
    local -a row
    for str in "$@"; do
        row=( $( echo "$str" ) )
        for el in "${row[@]}"; do
            echo -n "$el${LSEP}"
        done
    done
}




# Uses first parameter as subject value, then puts the rest
# of the parameters into a list element.
pick_from_array()
{
    local subject="$1"

    local cmd=(
        "${YAD_COMMON_ARGS[@]}"
        --list
        --text "Select a ${subject} from the following list."
        --button "_Open File":2
        --button "Cancel":1
        --button "OK":0
        --no-headers
        --column "${subject}":TEXT
        "${@:2}"
    )

    local -i exval

    result=$( yad "${cmd[@]}" )
    exval=$?
    case "$exval" in
        0)
            local IFS="${YSEP}"
            arr=( $( echo "${result}" ) )
            echo "${arr[0]}"
            return 0
            ;;
        2)
            open_gsf_file
            return 1
            ;;
        *)
            return $exval ;;
    esac

    return 0
}

# Dialog #1: Get database name from available databases.
show_select_dbase_dialog()
{
    local -a dbnames
    local -i exval
    local result

    result=$( pick_from_array "Database" "${DBASE_NAMES[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        set_dbase_name "${result}"
    fi
    return $exval
}

# Dialog 2: Get table name from list of tables in current database.
show_select_table_dialog()
{
    local -i exval
    local result

    result=$( pick_from_array "Table" "${TABLE_NAMES[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        set_table_name "${result}"
    fi
    return $exval
}

## Dialog #3: 
show_table_preferences_dialog()
{
    local result
    local -i exval
    local -i PLUG_NUM=$(( G_PLUG_NUM++ ))

    if [ -z "${GF_FILE_ARG}" ]; then
        set_file_path_defaults "${PWD}/${GF_DBNAME}_${GF_TNAME}.gsf"
    fi

    while true; do
        result=$(
            # start_default_labels_list_dialog "${PLUG_NUM}" 1
            start_table_preferences_meta_pane "${PLUG_NUM}" 1
            start_table_preferences_list_pane "${PLUG_NUM}" 2
            yad --key "${PLUG_NUM}" "${TABLE_PREFERENCES_DIALOG[@]}"
            )
        exval=$?
        case $exval in
            1|252) break ;; # Pressed  Cancel (1) or ESC or window close (252)
            0) show_interaction_preferences_dialog "$result" ;; # Pressed OK
            2) show_save_files_dialog ;;
            3) show_default_column_labels_dialog ;;
        esac
    done
}

# Dialog 3 sub-dialog (top pane)
start_table_preferences_meta_pane()
{
    local -i plug="$1"
    local -i tnum="$2"

    local -i fcount=$( get_fields_count )

    cmd=( --plug "${plug}"
          --tabnum "${tnum}"
          --form
          --separator "${YSEP}"
          --field "Database":RO "${GF_DBNAME}"
          --field "Table":RO "${GF_TNAME}"
          --field "Field Count":RO "${fcount}"
        )

    if [ -n "${GF_FILE_ARG}" ]; then
        cmd=( "${cmd[@]}"
              --field "Settings File":RO "${GF_FILEPATH_GSF}"
            )
    fi

    yad "${cmd[@]}" &
}

# Dialog 3 sub-dialog (bottom pane)
start_table_preferences_list_pane()
{
    local -i plug="$1"
    local -i tnum="$2"
    yad --tabnum "${tnum}" --plug "${plug}" \
        "${IACT_TYPES_LIST[@]}" \
        "${IACT_NAMES[@]}" &
}

# Dialog #4: Set field usage and display flags for an interaction type
show_interaction_preferences_dialog()
{
    # Break result into lines for each pane:
    local IFS=$'\n'
    local -a lines=( $( echo "$1" ) )

    # Break each line into an array.  The array with
    # a single element will be the chosen interaction.

    # IFS for parsing YAD value from each line
    IFS="${YSEP}"

    local -a row
    local line iact
    for line in "${lines[@]}"; do
        row=( $( echo "$line" ) )
        if [ "${#row[@]}" -eq 1 ]; then
            iact="${row[0]}"
            break
        fi
    done
    
    local meta_vals_str=$( get_iact_meta_vals_str "${iact}" )
    local list_vals_str=$( get_iact_list_data_str "${iact}" )

    # IFS for parsing our stuff:
    IFS="${YSEP}"
    local -a meta_vals=( $( echo "${meta_vals_str}" ) )
    local -a list_vals=( $( echo "${list_vals_str}" ) )

    local IACT_NAME="${meta_vals[0]}"

    local result
    local -i exval
    local -i PLUG_NUM=$(( G_PLUG_NUM++ ))

    local -a top_pane=(
        --plug "${PLUG_NUM}"
        --text "Interaction Editor for ${GF_DBNAME}.${GF_TNAME}"
        "${IACT_TOP_PANE[@]}"
    )

    local -a list_pane=(
        --plug "${PLUG_NUM}"
        "${IACT_LIST_PANE[@]}"
    )

    local -a paned_dialog=(
        --key "${PLUG_NUM}"
        "${YAD_COMMON_ARGS[@]}"
        "${INTERACTION_PREFERENCES_DIALOG[@]}"
    )

    local script_text

    while true; do
        result=$(
            yad "${top_pane[@]}" "${meta_vals[@]}" &
            yad "${list_pane[@]}" "${list_vals[@]}" &
            yad "${paned_dialog[@]}"
              )
        exval=$?

        case $exval in
            0) save_iact_choices "${result}"; break ;;
            2|3)
                local cmd_to_call
                if [ $exval -eq 2 ]; then
                    cmd_to_call="gsf_write_script_sql"
                else
                    cmd_to_call="gsf_write_script_srm"
                fi
                IFS="${FSEP}"
                local -a IACT_COL_PREFS
                IACT_COL_PREFS=( $( make_iact_choices_string "${result}" ) )
                script_text=$( $cmd_to_call "${IACT_NAME}" )
                if [ $? -eq 0 ]; then  echo "${script_text}"; fi

                # Update array for re-initialize the dialog:
                meta_vals=( "${iact}" $( split_yad_arrs "${IACT_COL_PREFS[0]}" ) )
                list_vals=( $( split_yad_arrs "${IACT_COL_PREFS[@]:1}" ) )
                ;;
            1|252) break ;;
        esac
    done
}

## Dialog #5: Set default field labels for current table.
#
# Tables with few fields can use a form, but longer lists require
# a scrolling list with which to set default column names.
show_default_column_labels_dialog()
{
    local -i fcount=$( get_fields_count )
    if [ "$fcount" -lt 15 ]; then
        start_default_labels_form_dialog
    else
        start_default_labels_list_dialog
    fi
}

# Dialog #5 for short lists of fields (uses a form dialog)
start_default_labels_form_dialog()
{
    local -i plug=0
    local -a cmd

    if [ $# -ge 2 ]; then
        plug="$1"
        cmd=( --plug "$1" --tabnum "$2" )
    else
        cmd=( "${YAD_COMMON_ARGS[@]}" )
    fi

    cmd=( "${cmd[@]}"
          --text "Set default field labels."
          --always-print-result
          --form
        )

    local rowstr
    local -a row arr_data

    # Add list rows
    local -i ndx="${#cmd[@]}"
    local IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "$rowstr") )
        cmd[ $(( ndx++ )) ]="--field"
        cmd[ $(( ndx++ )) ]="${row[$COL_NAME]}:"
    done

    cmd=( "${cmd[@]}" "${GSF_FIELD_LABELS[@]}" )
        

    if [ "$plug" -gt 0 ]; then
        yad "${cmd[@]}" &
    else
        local -i exval
        local result
        result=$( yad "${cmd[@]}" )
        exval=$?

        if [ $exval -eq 0 ]; then
            IFS="${YSEP}"
            GSF_FIELD_LABELS=( $( echo "$result" ) )
        fi
    fi

    if [ $? -ne 0 ]; then
        echo "yad failed:" >&2
        printf "'%s'\n" "${cmd[@]}" >&2
        return 1
    else
        return 0
    fi
}

# Dialog #5 for long lists of fields (uses a list dialog)
start_default_labels_list_dialog()
{
    local -i plug=0
    local -a cmd

    if [ $# -ge 2 ]; then
        plug="$1"
        cmd=( --plug "$1" --tabnum "$2" )
    else
        cmd=( "${YAD_COMMON_ARGS[@]}" )
    fi

    cmd=( "${cmd[@]}"
          --list
          --always-print-result
          --print-all
          --editable
          --editable-cols 2
          --column "Column":TEXT
          --column "Label":TEXT
        )

    local rowstr
    local -a row arr_data

    # Add list rows
    local -i ndx="${#cmd[@]}"
    local -i vndx=0
    local IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "$rowstr") )
        cmd[ $(( ndx++ )) ]="${row[$COL_NAME]}"
        cmd[ $(( ndx++ )) ]="${GSF_FIELD_LABELS[$(( vndx++ ))]}"
    done

    if [ "$plug" -gt 0 ]; then
        yad "${cmd[@]}" &
    else
        local result
        local -i exval
        result=$( yad "${cmd[@]}" )
        exval=$?
        if [ $exval -eq 0 ]; then
            GSF_FIELD_LABELS=( $( array_str_from_list_result 1 "$result" ) )
            declare -p GSF_FIELD_LABELS
        fi
    fi
}

## Dialog #6:
show_save_files_dialog()
{
    local -a cmd
    cmd=(
        "${YAD_COMMON_ARGS[@]}"
        --form
        --field "Write settings file":CHK "FALSE"
        --field "GSF file name":SFL "${GF_FILEPATH_GSF}"
        --field "Write SQL script":CHK "FALSE"
        --field "SQL file name":SFL "${GF_FILEPATH_SQL}"
        --field "Write SRM script":CHK "FALSE"
        --field "SRM file name":SFL "${GF_FILEPATH_SRM}"
    )

    local result=$( yad "${cmd[@]}" )
    local -i exval=$?

    if [ $exval -eq 0 ]; then
        local IFS="${YSEP}"
        local -i index=0
        rarr=( $( echo "${result}" ) )
        

        if [ "${rarr[ $(( index++ )) ]}" = "TRUE" ]; then
            save_settings_to_file "${rarr[ $(( index++)) ]}"
        fi

        if [ "${arr[ $(( index++ )) ]}" = "TRUE" ]; then
            save_srm_to_file "${rarr[ $$(( index++ )) ]}"
        fi

        if [ "${arr[ $(( index++ )) ]}" = "TRUE" ]; then
            save_sql_to_file "${rarr[ $(( index++ )) ]}"
        fi
    fi
}


use_table_info()
{
    collect_column_indexes
    update_field_names_array
    $use_table_info_callback
}

collect_table_info()
{
    local use_table_info_callback="${1:-show_table_preferences_dialog}"

    if ! confirm_dbase_name || ! confirm_table_name ; then
        echo "SQL Injection test failed.  Attempt to set" >&2
        echo "Database name = '${GF_DBNAME}', and" >&2
        echo "Table name = '${GF_TNAME}'" >&2
        exit 1
    fi

    query="\
${COLS_QUERY}
WHERE TABLE_SCHEMA='${GF_DBNAME}'
AND TABLE_NAME='${GF_TNAME}'"

    source bashmysql -s "${SEPS}" "information_schema" "${query}" -c use_table_info
}

table_field_is_index()
{
    local IFS="${FSEP}"
    local name="$1"
    local lrowstr
    local -a row

    for lrowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "${lrowstr}" ) )
        if [ "${row[$COL_NAME]}" = "$name" -a -n "${row[$COL_PRIKEY]}" ]; then
            return 0
        fi
    done
    return 1
}

table_get_primary_key()
{
    local rowstr
    local -a row
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "${rowstr}" ) )
        if [ -n "${row[$COL_PRIKEY]}" ]; then
            echo "${row[$COL_NAME]}"
            return 0
        fi
    done
    return 1
}


loop_for_context()
{
    local -i do_loop=0
    local -i do_dbase_loop=$( test -z "$GF_DBNAME"; echo $? )

    local tresult dresult
    local -i exval

    while [ $do_loop -eq 0 ]; do
        if [ $do_dbase_loop -eq 0 ]; then
            show_select_dbase_dialog
            exval=$?
            if [ $exval -ne 0 ]; then
                GF_DBNAME=
                do_dbase_loop=1
                do_loop=1
            fi
        fi

        while [ -n "$GF_DBNAME" ]; do
            reset_for_new_table
            show_select_table_dialog
            exval=$?
            if [ $exval -eq 0 ]; then
                collect_table_info "show_table_preferences_dialog"
            elif [ $do_dbase_loop -ne 0 ]; then
                do_loop=1
                break
            else
                break
            fi
        done
    done
}


parse_args "$@"
if [ -z "$GF_FILE_ARG" ]; then
    if [ -n "$GF_TNAME" -a -n "$GF_DBNAME" ]; then
        collect_table_info "show_table_preferences_dialog"
    else
        loop_for_context
    fi
fi




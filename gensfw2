#!/bin/bash

# Primary Dialogs in this application (many dialogs have sub-dialogs):
# 1: Select Database from List (or open GSF file)
# 2: Select Table from List (or open GSF file)
# 3: Edit Table Preferences Dialog, can start dialogs 4, 5, and 6
# 4: Edit Interaction Preferences Dialog
# 5: Set Default Column Labels
# 6: Save Files Dialog

source gensfw2_bacts
source gensfw2_scripts

# One or the other of the following, either override
# default SEPS (first line), or get the default SEPS
# values from bashmysql:
SEPS='@#$'
# SEPS=$( bashmysql -S )

RSEP="${SEPS:0:1}"
FSEP="${SEPS:1:1}"
VSEP="${SEPS:2:1}"

YSEP="${FSEP}"
YSEP='^'

declare -a IACT_NAMES=( List Add Read Update Delete Import )
declare -a IACT_COLUMNS=( Type Param Result Readonly Hide Label )

declare -gi G_PLUG_NUM=$$ ## Commence plug numbers from process id

# COL_xxxx integers are indexes to column for result of COLS_QUERY
# These will not change once set
declare -gi COL_NAME
declare -gi COL_TYPE
declare -gi COL_PRIKEY
declare -gi COL_DEFAULT

# The list of available database won't change (unless we change hosts):
declare -a DBASE_NAMES=( $( mysql -BN -e "show databases" ) ) 

# The next two variables can be either set from command line,
# from dialogs 1 and 2, or by opening a settings file:
declare -gx GF_DBNAME
declare -gx GF_TNAME

# 
declare -gx GF_SETTINGS_FILE
declare -gx GF_SCRIPTS_FILE

# This array changes when GF_DBNAME changes (from Dialog 1):
declare -a TABLE_NAMES

declare -a GSF_FIELD_NAMES  # Initialized when a table is selected
declare -a GSF_FIELD_LABELS # From settings file or by using Dialog 5 (default labels)

declare -a IACT_FIELD_LABELS
declare -A IACT_DATA

# Clear variables that might retain info from previous table:
reset_for_new_table()
{
    GF_SETTINGS_FILE=
    GF_SCRIPTS_FILE=
    GSF_FIELD_NAMES=()
    GSF_FIELD_LABELS=()
}

# Convenient function to avoid having to know the array name:
get_fields_count() { echo "${#GSF_FIELD_NAMES[@]}"; }

# All primary yad dialogs should use this
# (Not paned or notebook plugs):
declare -a YAD_COMMON_ARGS=(
    --height 500
    --width 750
    --center
    --borders 10
    --separator "${YSEP}"
    --title "Generate Schema Framework Scripts"
)


### Dialog #3: Table Preferences Dialog ###
### Usde in function: show_table_preferences_dialog()
# Primary yad dialog, for current dbase/table
# - Select interaction types to edit
# - Set default column labels
# - Save script and settings files
declare -a TABLE_PREFERENCES_DIALOG=(
    "${YAD_COMMON_ARGS[@]}"
    --paned
    --tab "Tab1"
    --tab "Tab2"
    --button "Set _Labels":3
    --button "Save _Files":2
    --button "Cancel":1
    --button "_OK":0
    )

# Dialog #3 top pane, call start_table_preferences_meta_pane()

# Dialog #3, bottom pane, before adding data:
declare -a IACT_TYPES_LIST=(
    --text "Click on an interaction type to set column preferences."
    --list
    --separator "${YSEP}"
    --column "Interaction Type":TEXT
)


### Dialog #4: Interaction Settings Dialog
### Use in function: show_interaction_preferences_dialog()
# Primary yad dialog, set column preferences for the interaction.
declare -a INTERACTION_PREFERENCES_DIALOG=(
    --paned
    --tab="Tab1"
    --tab="Tab2"
    --button "Show S_RM":3
    --button "Show S_QL":2
    --button "Cancel":1
    --button "_Ok":0
    )

# Dialog #4 top pane, before data added:
declare -a IACT_TOP_PANE=(
    --tabnum=1
    --form
    --separator "${YSEP}"
    --field "Interaction":RO
    --field "Include":CHK
    )


# Dialog #4 bottom pane, before data added:
declare -a IACT_LIST_PANE=(
    --tabnum=2
    --list
    --always-print-result
    --separator "${YSEP}"
    --print-all
    --editable
    --editable-cols 6
    --column "Column Name":TEXT
    --column "Type":TEXT
    --column "Param":CHK
    --column "Result":CHK
    --column "Readonly":CHK
    --column "Hide":CHK
    --column "Label":TEXT
)

# Set every interaction type values to not included."
reset_IACT_DATA()
{
    IACT_DATA=()
    local name
    for name in "${IACT_NAMES[@]}"; do
        IACT_DATA[$name]="FALSE"
    done
}
# Intialize for first use:
reset_IACT_DATA


declare COLS_QUERY="\
SELECT COLUMN_NAME,
       UPPER(DATA_TYPE) AS DATA_TYPE,
       CHARACTER_MAXIMUM_LENGTH,
       COLUMN_TYPE,
       CASE WHEN INSTR(EXTRA,'auto_increment') THEN 'YES' ELSE NULL END AS autoinc,
       CASE WHEN INSTR(COLUMN_KEY,'PRI') THEN 'YES' ELSE NULL END AS prikey,
       NULLIF(IS_NULLABLE,'NO') AS nullable,
       NUMERIC_PRECISION,
       NUMERIC_SCALE,
       COLUMN_DEFAULT
  FROM COLUMNS"


# Save column indexes to global variables for repeated access
collect_column_indexes()
{
    declare -i ndx
    declare -i exval=0

    # Use nested function to reuse repeated code.
    # First failure to find skips the rest.
    get_index()
    {
        if [ $exval -eq 0 ]; then
            ndx=$( find_column_index "$1" )
            exval=$?
            if [ $exval -ne 0 ]; then
                echo "Can't find column '$1'." >&2
                exit $exval
            fi
        fi
    }

    get_index "COLUMN_NAME";    COL_NAME=$ndx
    get_index "DATA_TYPE";      COL_TYPE=$ndx
    get_index "prikey";         COL_PRIKEY=$ndx
    get_index "COLUMN_DEFAULT"; COL_DEFAULT=$ndx
}

# Get field names from global table information
update_field_names_array()
{
    GSF_FIELD_NAMES=()

    declare rowstr
    declare -a row
    declare -i ndx=0
    local IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "${rowstr}" ) ) 
        GSF_FIELD_NAMES[$ndx]="${row[$COL_NAME]}"
        GSF_FIELD_LABELS[$ndx]=""
        (( ndx++ ))
    done
}

get_iact_meta_vals_str()
{
    local -i exval
    local itype="$1"
    local metastr
    local -a savedvals
    local LSEP="${YSEP}"

    metastr="${IACT_DATA[$itype]}"

    exval=$?
    if [ $exval -ne 0 ]; then
        echo "Error retrieving data for the '${itype}' interaction." >&2
        exit $exval
    fi
    savedvals=( $( echo "$metastr" ) )
    echo "${itype}${LSEP}${savedvals[0]}"
}

# get_iact_list_data_str()
# This function unpacks the data that was compiled by save_iact_choices().
get_iact_list_data_str()
{
    local itype="$1"
    local IFS="${YSEP}"

    # Using a local alias for output separator
    local LSEP="${YSEP}"

    # First check if the interaction type has a saved value:
    local -i exval
    local -a vals ovals
    local valstr="${IACT_DATA[$itype]}"
    exval=$?
    if [ $exval -eq 0 ]; then
        IFS="${YSEP}"
        vals=( $( echo "${valstr}" ) )
        exval=$?
        if [ $exval -eq 0 -a "${#vals[@]}" -gt 1 ]; then
            IFS="${LSEP}"
            echo "${vals[*]:1}"

            vals_copy=( $( echo "${vals[*]:1}" ) )
            return 0
        fi
    fi

    # If no saved value, return a default string to start with:
    local rowstr
    local -a row
    local -i is_index

    # Reset IFS to parse fields from rowstr from bashmysql:
    IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "$rowstr") )

        is_index=$( [ -n "${row[$COL_PRIKEY]}" ]; echo $? )

        # Skip field if not a new record:
        if [[ $is_index -eq 0 && " Add Import " =~ "${itype}" ]]; then
            continue
        fi

        # Information/Identification column (name and datatype)
        echo -n "${row[COL_NAME]}${LSEP}${row[COL_TYPE]}"

        # The Param and Result columns a flags to include the field
        # in the respective domain.  Fields for which the Param flag
        # is set will be include the field in the parameter list.
        # Likewise, fields for which the Result flag will be included
        # in the results by adding the field to the  SELECT clause
        # of the query.

        # Param column, FALSE for List, Read, and Delete, TRUE otherwise
        local param_false=" List Read Delete "
        if [[ $is_index -ne 0 && " List Read Delete " =~ " ${itype} " ]]; then
            echo -n "${LSEP}FALSE"
        else
            echo -n "${LSEP}TRUE"
        fi

        # Result column, TRUE for List, Read, otherwise FALSE
        if [ $itype == "List" -o $itype == "Read" ]; then
            echo -n "${LSEP}TRUE"
        else
            echo -n "${LSEP}FALSE"
        fi

        # Readonly and Hide (For index fields)
        if [ $is_index -eq 0 ]; then
            echo -n "${LSEP}TRUE${LSEP}TRUE"
        else
            echo -n "${LSEP}FALSE${LSEP}FALSE"
        fi

        # Blank element for the label, printing newline at end of row
        echo -n "${LSEP}"
        echo -n "${LSEP}"

    done
}

# save_iact_choices():
# Converts result of dialog #4 to a string with table fields
# separated by FSEP and the field preferences separated by YSEP,
# with the string saved to the Associated array IACT_DATA
save_iact_choices()
{
    local IFS
    local line
    local -a lines choices row

    # These are used to set and build a record value:
    local iact_name
    local iact_incl
    local -a iact_frows

    # First split to rows:
    IFS=$'\n'
    lines=( $(echo "$1" ) )

    for line in "${lines[@]}"; do
        IFS="${YSEP}"
        row=( $( echo "${line}" ) )
        if [ "${#row[@]}" -lt 4 ]; then
            iact_name="${row[0]}"
            iact_incl="${row[1]}"
        else
            IFS="${YSEP}"
            rowstr="${row[*]}"
            IFS="${FSEP}"
            # iact_frows=( "${iact_frows[@]}" "${row[@]}" )
            iact_frows=( "${iact_frows[@]}" "${rowstr}" )
        fi
    done

    IFS="${FSEP}"
    IACT_DATA["$iact_name"]="${iact_incl}${FSEP}${iact_frows[*]}"

    echo "${IACT_DATA[$iact_name]}" >&2

}

index_in_array()
{
    local target="$1"
    local el
    local -i ndx=0
    for el in "${@:2}"; do
        if [ "$el" == "$target" ]; then
            echo "$ndx"
            return 0
        fi
        (( ndx++ ))
    done
    return 1
}

string_in_array()
{
    local target="$1"
    local el
    for el in "${@:2}"; do
        if [ "$el" == "$target" ]; then
            return 0
        fi
    done
    return 1
}

confirm_dbase_name() { string_in_array "${GF_DBNAME}" "${DBASE_NAMES[@]}"; }
confirm_table_name() { string_in_array "${GF_TNAME}" "${TABLE_NAMES[@]}"; }
confirm_iact_name()  { string_in_array "$1" "${IACT_NAMES[@]}"; }

set_dbase_name()
{
    GF_TNAME=
    TABLE_NAMES=()
    if string_in_array "$1" "${DBASE_NAMES[@]}" ; then
        GF_DBNAME="$1"
        local IFS=$'\n'
        TABLE_NAMES=( $( mysql "${GF_DBNAME}" -BN -e "show tables" ) )
    else
        echo "'$1' is not a database name on this server." >&2
        exit 1
    fi
}

set_table_name()
{
    if string_in_array "$1" "${TABLE_NAMES[@]}"; then
        GF_TNAME="$1"
    else
        echo "'$1' is not a table name in the ${GF_DBNAME} database." >&2
        exit 1
    fi
}


# This function can terminate the script with an unknown database
# or table name.  Thus, there is no return value for this function.
parse_args()
{
    local arg
    for arg in "$@"; do
        if [ -f "${arg}" ]; then
            GF_SETTINGS_FILE="${arg}"
            gsf_read_settings_from_file "${arg}"
            break
        elif [ -z "$GF_DBNAME" ]; then
            set_dbase_name "$arg"
        elif [ -z "$GF_TNAME" ]; then
            set_table_name "$arg"
        fi
    done
}

# Using the first character of IFS as the separator, this function creates a
# string of values from a specified column of a list result.
#
# For example, local -a arr=( $( array_str_from_list_result 1 "$result" ) )
# will make an array from the second column of the list result.
array_str_from_list_result()
{
    local -a lines vals
    local line
    local -i col="$1"

    # Save IFS character before we change IFS
    local VSEP="${IFS:0:1}"

    # List results separated by newlines:
    local IFS=$'\n'
    lines=( $( echo "$2" ) )

    # Set IFS to split each line into values:
    IFS="${YSEP}"
    for line in "${lines[@]}"; do
        vals=( $( echo "$line" ) )
        # Echo each value, followed by the VSEP value we saved above:
        echo -n "${vals[$col]}${VSEP}"
    done
}


# Uses first parameter as subject value, then puts the rest
# of the parameters into a list element.
pick_from_array()
{
    local subject="$1"

    local cmd=(
        "${YAD_COMMON_ARGS[@]}"
        --list
        --text "Select a ${subject} from the following list."
        --button "_Open File":2
        --button "Cancel":1
        --button "OK":0
        --no-headers
        --column "${subject}":TEXT
        "${@:2}"
    )

    local -i exval

    result=$( yad "${cmd[@]}" )
    exval=$?
    case "$exval" in
        0)
            local IFS="${YSEP}"
            arr=( $( echo "${result}" ) )
            echo "${arr[0]}"
            return 0
            ;;
        2)
            open_gsf_file
            return 1
            ;;
        *)
            return $exval ;;
    esac

    return 0
}

# Dialog #1: Get database name from available databases.
show_select_dbase_dialog()
{
    local -a dbnames
    local -i exval
    local result

    result=$( pick_from_array "Database" "${DBASE_NAMES[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        set_dbase_name "${result}"
    fi
    return $exval
}

# Dialog 2: Get table name from list of tables in current database.
show_select_table_dialog()
{
    local -i exval
    local result

    result=$( pick_from_array "Table" "${TABLE_NAMES[@]}" )
    exval=$?
    if [ $exval -eq 0 ]; then
        set_table_name "${result}"
    fi
    return $exval
}

## Dialog #3: 
show_table_preferences_dialog()
{
    local -i pnum=$$
    local result
    local -i exval

    while true; do
        result=$(
            # start_default_labels_list_dialog "${pnum}" 1
            start_table_preferences_meta_pane "${pnum}" 1
            start_table_preferences_list_pane "${pnum}" 2
            yad --key "${pnum}" "${TABLE_PREFERENCES_DIALOG[@]}"
            )
        exval=$?
        case $exval in
            1|252) break ;; # Pressed  Cancel (1) or ESC or window close (252)
            0) show_interaction_preferences_dialog "$result" ;; # Pressed OK
            2) show_save_files_dialog ;;
            3) show_default_column_labels_dialog ;;
        esac
    done
}

# Dialog 3 sub-dialog (top pane)
start_table_preferences_meta_pane()
{
    local -i plug="$1"
    local -i tnum="$2"

    local -i fcount=$( get_fields_count )

    if [ -z "${GF_SETTINGS_FILE}" ]; then
        name_settings="${GF_DBNAME}_${GF_TNAME}.gsf"
    else
        name_settings="${GF_SETTINGS_FILE}"
    fi

    cmd=( --plug "${plug}"
          --tabnum "${tnum}"
          --form
          --separator "${YSEP}"
          --field "Database":RO "${GF_DBNAME}"
          --field "Table":RO "${GF_TNAME}"
          --field "Field Count":RO "${fcount}"
        )

    if [ -n "${GF_SETTINGS_FILE}" ]; then
        cmd=( "${cmd[@]}"
              --field "Settings File":RO "${name_settings}"
            )
    fi

    yad "${cmd[@]}" &
}

# Dialog 3 sub-dialog (bottom pane)
start_table_preferences_list_pane()
{
    local -i plug="$1"
    local -i tnum="$2"
    yad --tabnum "${tnum}" --plug "${plug}" \
        "${IACT_TYPES_LIST[@]}" \
        "${IACT_NAMES[@]}" &
}

# Dialog #4: Set field usage and display flags for an interaction type
show_interaction_preferences_dialog()
{
    # Break result into lines for each pane:
    local IFS=$'\n'
    local -a lines=( $( echo "$1" ) )

    # Break each line into an array.  The array with
    # a single element will be the chosen interaction.

    # IFS for parsing YAD value from each line
    IFS="${YSEP}"

    local -a row
    local line iact
    for line in "${lines[@]}"; do
        row=( $( echo "$line" ) )
        if [ "${#row[@]}" -eq 1 ]; then
            iact="${row[0]}"
            break
        fi
    done
    
    local meta_vals_str=$( get_iact_meta_vals_str "${iact}" )
    local list_vals_str=$( get_iact_list_data_str "${iact}" )

    # IFS for parsing our stuff:
    IFS="${YSEP}"
    local -a meta_vals=( $( echo "${meta_vals_str}" ) )
    local -a list_vals=( $( echo "${list_vals_str}" ) )

    local result
    local -i exval
    local -i PLUG_NUM=$(( G_PLUG_NUM++ ))

    local -a top_pane=(
        --plug "${PLUG_NUM}"
        --text "Interaction Editor for ${GF_DBNAME}.${GF_TNAME}"
        "${IACT_TOP_PANE[@]}"
        "${meta_vals[@]}"
    )

    local -a list_pane=(
        --plug "${PLUG_NUM}"
        "${IACT_LIST_PANE[@]}"
        "${list_vals[@]}"
    )

    local -a paned_dialog=(
        --key "${PLUG_NUM}"
        "${YAD_COMMON_ARGS[@]}"
        "${INTERACTION_PREFERENCES_DIALOG[@]}"
    )

    local script_text

    while true; do
        result=$(
            yad "${top_pane[@]}" &
            yad "${list_pane[@]}" &
            yad "${paned_dialog[@]}"
              )
        exval=$?

        case $exval in
            0) save_iact_choices "${result}"; break ;;
            2) script_text=$( gsf_parse_type_prefs "${iact}" "sql" )
               if [ $? -eq 0 ]; then  echo "${script_text}"; fi
               ;;
            2) script_text=$( gsf_parse_type_prefs "${iact}" "srm" )
               if [ $? -eq 0 ]; then  echo "${script_text}"; fi
               ;;
            1|252) break ;;
        esac
    done
}

## Dialog #5: Set default field labels for current table.
#
# Tables with few fields can use a form, but longer lists require
# a scrolling list with which to set default column names.
show_default_column_labels_dialog()
{
    local -i fcount=$( get_fields_count )
    if [ "$fcount" -lt 15 ]; then
        start_default_labels_form_dialog
    else
        start_default_labels_list_dialog
    fi
}

# Dialog #5 for short lists of fields (uses a form dialog)
start_default_labels_form_dialog()
{
    local -i plug=0
    local -a cmd

    if [ $# -ge 2 ]; then
        plug="$1"
        cmd=( --plug "$1" --tabnum "$2" )
    else
        cmd=( "${YAD_COMMON_ARGS[@]}" )
    fi

    cmd=( "${cmd[@]}"
          --text "Set default field labels."
          --always-print-result
          --form
        )

    local rowstr
    local -a row arr_data

    # Add list rows
    local -i ndx="${#cmd[@]}"
    local IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "$rowstr") )
        cmd[ $(( ndx++ )) ]="--field"
        cmd[ $(( ndx++ )) ]="${row[$COL_NAME]}:"
    done

    cmd=( "${cmd[@]}" "${GSF_FIELD_LABELS[@]}" )
        

    if [ "$plug" -gt 0 ]; then
        yad "${cmd[@]}" &
    else
        local -i exval
        local result
        result=$( yad "${cmd[@]}" )
        exval=$?

        if [ $exval -eq 0 ]; then
            IFS="${YSEP}"
            GSF_FIELD_LABELS=( $( echo "$result" ) )
        fi
    fi

    if [ $? -ne 0 ]; then
        echo "yad failed:" >&2
        printf "'%s'\n" "${cmd[@]}" >&2
        return 1
    else
        return 0
    fi
}

# Dialog #5 for long lists of fields (uses a list dialog)
start_default_labels_list_dialog()
{
    local -i plug=0
    local -a cmd

    if [ $# -ge 2 ]; then
        plug="$1"
        cmd=( --plug "$1" --tabnum "$2" )
    else
        cmd=( "${YAD_COMMON_ARGS[@]}" )
    fi

    cmd=( "${cmd[@]}"
          --list
          --always-print-result
          --print-all
          --editable
          --editable-cols 2
          --column "Column":TEXT
          --column "Label":TEXT
        )

    local rowstr
    local -a row arr_data

    # Add list rows
    local -i ndx="${#cmd[@]}"
    local -i vndx=0
    local IFS="${FSEP}"
    for rowstr in "${RESULT_ROWS[@]}"; do
        row=( $( echo "$rowstr") )
        cmd[ $(( ndx++ )) ]="${row[$COL_NAME]}"
        cmd[ $(( ndx++ )) ]="${GSF_FIELD_LABELS[$(( vndx++ ))]}"
    done

    if [ "$plug" -gt 0 ]; then
        yad "${cmd[@]}" &
    else
        local result
        local -i exval
        result=$( yad "${cmd[@]}" )
        exval=$?
        if [ $exval -eq 0 ]; then
            GSF_FIELD_LABELS=( $( array_str_from_list_result 1 "$result" ) )
            declare -p GSF_FIELD_LABELS
        fi
    fi
}

## Dialog #6:
show_save_files_dialog()
{
    write_scripts # to write SRM file
    save_settings # to write gsf file
}


use_table_info()
{
    collect_column_indexes
    update_field_names_array
    $use_table_info_callback
}

collect_table_info()
{
    local use_table_info_callback="${1:-show_table_preferences_dialog}"

    if ! confirm_dbase_name || ! confirm_table_name ; then
        echo "SQL Injection test failed.  Attempt to set" >&2
        echo "Database name = '${GF_DBNAME}', and" >&2
        echo "Table name = '${GF_TNAME}'" >&2
        exit 1
    fi

    query="\
${COLS_QUERY}
WHERE TABLE_SCHEMA='${GF_DBNAME}'
AND TABLE_NAME='${GF_TNAME}'"

    source bashmysql -s "${SEPS}" "information_schema" "${query}" -c use_table_info
}


loop_for_context()
{
    local -i do_loop=0
    local -i do_dbase_loop=$( test -z "$GF_DBNAME"; echo $? )

    local tresult dresult
    local -i exval

    while [ $do_loop -eq 0 ]; do
        if [ $do_dbase_loop -eq 0 ]; then
            show_select_dbase_dialog
            exval=$?
            if [ $exval -ne 0 ]; then
                GF_DBNAME=
                do_dbase_loop=1
                do_loop=1
            fi
        fi

        while [ -n "$GF_DBNAME" ]; do
            reset_for_new_table
            show_select_table_dialog
            exval=$?
            if [ $exval -eq 0 ]; then
                collect_table_info show_table_preferences_dialog
            elif [ $do_dbase_loop -ne 0 ]; then
                do_loop=1
                break
            else
                break
            fi
        done
    done
}


parse_args "$@"
if [ -n "$GF_TNAME" -a -n "$GF_DBNAME" ]; then
    collect_table_info show_table_preferences_dialog
else
    loop_for_context
fi




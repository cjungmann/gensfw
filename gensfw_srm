#!/usr/bin/env python3
""" Tool for modifying SRM files

This tool allows a user to make changes to an SRM file with command line
options.  Its purpose is to modify gensfw-generated scripts to illustrate
Schema Framework concepts and to make installation changes.

gensfw_es <filename>
"""
import sys
import types

# disable_pylint: disable=missing-docstring

class PStepError(Exception):
    """Raised for any parsing path error."""
    def __init__(self, message=None):
        super().__init__(message)

class SRMFileError(Exception):
    """Raised for any SRM file parsing error."""
    def __init__(self, message=None):
        super().__init__(message)

class SRMFileRangeError(SRMFileError):
    """Raised when an invalid range index is used."""
    def __init__(self, message=None):
        super().__init__(message)

def parse_srm_line(linestr):
    """Returns a (tag, value) tuple from an SRM file line,
    in which the values are both trimmed of leading and
    trailing spaces."""
    linestr = linestr.strip()
    tag = None
    value = None
    if linestr[0] == "#":
        tag = linestr
    else:
        parts = linestr.split(":", 1)
        tag = parts[0].strip()
        if len(parts) > 1:
            value = parts[1].strip()

    return (tag, value)

class PStep:
    """A linked class that identifies an acceptable match
    for a line in an SRM file."""
    def __init__(self, phrase_generator, starts_with=None):
        self.starts_with = starts_with
        self.tag = None
        self.value = None
        self.predicates = []
        self.next_step = None

        self.parse(phrase_generator)

    def node_test_set(self):
        """Boolean function returning initialization status."""
        return self.tag is not None

    def set_node_test(self, node_test):
        """Initializes the non-predicate part of the step."""
        self.tag, self.value = parse_srm_line(node_test)

    def node_test_str(self):
        """Builds a node_test string from the current state of the object."""
        if self.value:
            return "%s : %s" % (self.tag, self.value)
        elif self.tag:
            return self.tag
        else:
            return "unassigned"

    def parse(self, phrase_generator):
        """Recursive function that parses node test, predicate expression,
        and path step strings to build a linked PStep tree that can then
        be used to search an SRM document.

        :param phrase_generator: Generator that, with each next() call,
                                 returns a tuple with a string and the
                                 token that signalled the end of the
                                 string.
        :return: No return value.
        """
        try:
            while True:
                phrase, token = next(phrase_generator)

                # Test to set required because each predicate expression
                # passes through here, but only the first is preceded by
                # the node test.
                if not self.node_test_set() and len(phrase):
                    self.set_node_test(phrase)

                if token and token in "[]/":
                    if token == "[":
                        self.predicates.append(
                            PStep(phrase_generator, token)
                        )
                    elif token == "/":
                        self.next_step = PStep(phrase_generator, token)
                    elif token == "]":
                        if self.starts_with == "[":
                            break
                        else:
                            raise PStepError("Mismatched braces.")
        except StopIteration:
            pass

    def has_predicate(self):
        """Boolean test for existence of predicates.  Used mostly
        to communicate the intention of the code, that is, to make
        more clear the 'if' statement that calls it."""
        return len(self.predicates) > 0

    def __str__(self):
        """Override default __str__ function."""
        alist = [self.node_test_str()]
        for pred in self.predicates:
            alist.append("[%s]" % pred)
        if self.next_step is not None:
            alist.append("/%s" % self.next_step)

        return "".join(alist)

    def dump(self, level=0):
        """Prints out a representation of the PStep with its links.
        It is meant to be used for debugging how a SRM path is
        evaluated."""
        indent = ('..' * level)
        print("%snode_test: %s" % (indent, self.node_test_str()))
        print("%s...tag: %s" % (indent, self.tag))
        for pred in self.predicates:
            print("%s...[%s]" % (indent, str(pred)))

        if self.next_step is not None:
            self.next_step.dump(level+1)


def read_path_string(path_string):
    """Generator function that allows parsing of a path string
    with a single pass through its characters.  It yields a
    tuple with a string and the character that signalled the
    string's end.

    This generator is used by the PStep class, especially the
    parse method of the PStep class."""

    buff = []

    for char in path_string:
        if char in "[]/":
            yield ("".join(buff), char)
            buff = []
        else:
            buff.append(char)

    # Flush the buffer (final step without terminating token)
    if len(buff):
        yield("".join(buff), None)

def build_pstep(pathstr):
    """Global command to build a PStep tree from a pathstr."""
    return PStep(read_path_string(pathstr))

class SRMLine:
    """Represents a single line of an SRM file that contains
    values for the level of the line and values for the tag
    and value parts of the SRM line."""
    def __init__(self, level=0, tag=None, value=None):
        self.level = level
        self.value = value
        self.tag = tag

    def __str__(self):
        """Override default __str__ function."""
        if self.tag:
            parts = [self.tag]
            if self.value and len(self.value) > 0:
                parts.append(" : %s" % self.value)
            return "".join(parts)
        else:
            return ""

    def is_comment(self):
        """Returns True if the line is a comment, False otherwise."""
        return self.tag and self.tag[0] == "#"

    def is_empty(self):
        """Returns True for an empty line, False otherwise."""
        return self.tag is None

    def is_content(self):
        """Returns True if the line is a content line, False otherwise.
        A content line is a non-comment line that has at least a tag value."""
        return not (self.is_comment() or self.is_empty())

    def display(self, colon_align=None):
        """Prints the line according to its contents.

        :param colon_align: Setting this optional parameter
           will pad the printout of the *tag* value to align
           the colon for a more pleasing-to-read output.

        This method prints 3 spaces per level, then the
        tag.  If the line includes a value, a comma and the
        value string will be printed following the tag."""

        if self.level:
            print("   " * self.level, end="")
        if self.tag:
            print(self.tag, end="")
            if self.value:
                if colon_align:
                    colon_spaces = " " * (colon_align - self.tag_len())
                    print(colon_spaces, end="")

                print(" : %s" % self.value, end="")
        print()

    def tag_len(self):
        """This method returns the length of the tag value,
        unless the line is a comment type, in which case the
        tag_len will be 0.
        """

        if self.tag and not self.is_comment():
            return len(self.tag)
        else:
            return 0

    def matches_pstep(self, pstep):
        """Returns equivalence value of a node test comparison
        between this line and a given PStep object.

        Comments cannot be matched and always return False."""
        if self.is_comment():
            return False

        if pstep.tag and pstep.tag == self.tag:
            return pstep.value is None or pstep.value == self.value
        else:
            return False

class SRMLineParser:
    """Parses lines of an SRM file, creating an SRMLine object
    that can then be added to an SRMFile.

    The best use of an SRMLineParser object is to use a single
    instance to parse all the lines of an SRM file.  The parser
    tracks consecutive lines to deduce the intended level, so
    using a new SRMLineParser to process different lines will
    hinder the object's ability to recognize levels.
    """

    level_stops = [0]
    lines_parsed = 0
    bad_level_msg = ("Spaces count in line not "
                     "previously used in current "
                     "branch.")

    def __init__(self):
        self.level_stops = [0]
        self.lines_parsed = 0

    def cur_level_spaces(self):
        """Returns the current inferred level value of the
        current line based on the number of spaces that precede
        tag of this and previous SRM lines."""
        return self.level_stops[-1]

    def get_level_from_spaces_count(self, spaces_count):
        """This method deduces the current line's hierachical
        level based on the number of leading spaces of consecutive
        lines and a persistent record of the indentation level of
        previous level definitions.

        Possible "Bad Level" Exception
        ------------------------------

        This method may raise an exception if the levels are disordered.
        Confusion occurs when the indentation of a line decreases from
        the previous line to a greater indentation level than the new
        lines parent line.

        The following shows a disordered indentation:

        edit
           procedure   : App_Item_Update
           schema_proc : App_Item_Value
           schema
              button
                 type : add
                label : Add
              button
                 type : delete
                 label : Delete


        Notice the two lines under the first *button*.  The *type : add*
        and *label : Add* lines look to be siblings under the *button*
        parent line, but since the indentation levels are not consistent,
        the appropriate level can only be guessed.

        This type of error can be much less obvious if the siblings are
        separated by many lines of code.
        """
        if spaces_count > self.cur_level_spaces():
            self.level_stops.append(spaces_count)
            return len(self.level_stops) - 1
        elif spaces_count == self.cur_level_spaces():
            return len(self.level_stops) - 1
        else:
            # backing down levels, must be in level_stops:
            while self.level_stops[-1] > spaces_count:
                self.level_stops.pop()

            if self.level_stops[-1] == spaces_count:
                return len(self.level_stops) - 1
            else:
                raise SRMFileError(self.bad_level_msg)

    def parse_line(self, line):
        """Returns an SRMLine object by interpreting the 'line'
        parameter in the context of the preceding lines in the
        SRM file."""
        self.lines_parsed += 1
        sline = line.lstrip()
        spaces = len(line) - len(sline)

        level = self.get_level_from_spaces_count(spaces)
        tag = None
        value = None

        if len(sline):
            tag, value = parse_srm_line(sline)
        else:
            # Override level for a blank line
            level = 0

        return SRMLine(level, tag, value)

class SRMFile:
    """This class contains the parsed contents of an SRM file."""

    lines_list = []
    def __init__(self, filepath=None):
        self.lines_list = []
        if filepath != None:
            self.initialize(filepath)

    def initialize(self, filepath):
        """Parses all lines contained in the file to create a
        list of SRMLines."""
        self.lines_list = []
        with open(filepath) as fileobj:
            parser = SRMLineParser()
            for line in fileobj:
                self.lines_list.append(parser.parse_line(line.rstrip()))

    def get_line_count(self):
        """Returns number of lines in the list for creating a range."""
        return len(self.lines_list)

    def in_range(self, index):
        """Boolean function that confirms or refutes that a index number
        represents an existing line in the lines_list."""
        return index >= 0 and index < self.get_line_count()

    def level_at_index_inclusive(self, index):
        """Returns the inferred tree level of an SRMLine at the index.
        This method is used to compare the relationship of consecutive
        lines to identify siblings and the end of a run of siblings.

        Comments and empty lines are valid in this method and will
        return an implied tree level according to normal rules."""
        if self.in_range(index):
            return self.lines_list[index].level
        else:
            return -1

    def level_at_index(self, index):
        """Returns the inferred tree level of an SRMLine at the index,
        including only instruction lines.  That is, it will return -1
        if the line is comment or is empty."""
        if self.in_range(index):
            line = self.lines_list[index]
            if line.is_comment() or line.is_empty():
                return -1
            else:
                return line.level
        else:
            return -1

    def is_content_at_index(self, index):
        """Returns is_content() result for SRMLine at index."""
        return self.in_range(index) and self.lines_list[index].is_content()

    def is_empty_at_index(self, index):
        """Returns is_empty() result for SRMLine at index."""
        return self.in_range(index) and self.lines_list[index].is_empty()

    def get_unchecked_line_at(self, index):
        """Unconditionally return an SRM line from the lines_list as
        indicated by the index parameter.  Use this function instead
        of the safer 'get_line_at' when the index has already been
        confirmed."""
        return self.lines_list[index]

    def get_line_at(self, index):
        """Return an SRM line from the lines_list as indicated by
        the index parameter.  Returns None if the index is out of
        range."""
        if self.in_range(index):
            return self.get_unchecked_line_at(index)
        else:
            return None

    def get_first_child_index(self, index):
        """Get first child line of SRMLine at index."""
        if self.in_range(index):
            line = self.get_unchecked_line_at(index)
            level = line.level + 1
            for ndx in range(index+1, self.get_line_count()):
                line = self.get_unchecked_line_at(ndx)
                if line.level > level:
                    continue
                elif line.level < level:
                    break
                elif not line.is_comment():
                    return ndx

        return -1

    def get_last_child_index(self, index):
        """Get last child line of SRMLine at index."""
        lastchild = -1
        if self.in_range(index):
            line = self.get_unchecked_line_at(index)
            level = line.level + 1
            for ndx in range(index+1, self.get_line_count()):
                line = self.get_unchecked_line_at(ndx)
                if line.level > level:
                    continue
                elif line.level < level:
                    break
                elif not line.is_comment():
                    lastchild = ndx

        return lastchild

    def get_last_offspring_index(self, index):
        """Returns the line index of the last line whose ancestor
        is the reference line."""
        level = self.level_at_index(index)
        limit = self.get_line_count()

        # Predefine to preempt pylint3
        ndx = 0

        # Walk list to first non-offspring line
        for ndx in range(index+1, limit):
            ilevel = self.level_at_index(ndx)
            if ilevel < 0 or ilevel > level:
                continue
            if ilevel <= level:
                break
        else:
            return ndx

        # Back one to first line before first non-offspring line
        ndx -= 1

        # Back-off any space or comment lines:
        while ndx > index:
            if self.is_empty_at_index(ndx-1):
                ndx -= 1
            else:
                break

        return ndx

    def append_after_last_child(self, index, linestr):
        """Splicing function to insert a new line at the indicated position.
        The 'linestr' string will be parsed for tag and value, and the level
        of the new SRMLine will match that of the last child."""

        # Make new SRMLine with level of child of reference (ie 1 greater):
        level = self.level_at_index(index)
        tag, value = parse_srm_line(linestr)
        newline = SRMLine(level+1, tag, value)

        ndx = self.get_last_offspring_index(index)

        if self.in_range(ndx):
            self.lines_list.insert(ndx, newline)
        else:
            self.lines_list.append(newline)

    def insert_before_sibling(self, index, linestr):
        """Insert a new SRMLine just before, and
        at the same level as the indicated line."""
        if self.in_range(index):
            tag, value = parse_srm_line(linestr)
            line = self.get_unchecked_line_at(index)
            self.lines_list.insert(index,
                                   SRMLine(line.level, tag, value))

    def insert_after_sibling(self, index, linestr):
        """Insert a new SRMLine just after, and
        at the same level as the indicated line."""
        if self.in_range(index):
            tag, value = parse_srm_line(linestr)
            line = self.get_unchecked_line_at(index)

            # Since the lines are flat (not in a tree), the level of
            # the next line doesn't matter. If it exists, we can just
            # insert a line before it with the appropriate level.
            if self.in_range(index+1):
                self.lines_list.insert(index+1,
                                       SRMLine(line.level, tag, value))
            # If the target line is the last line in the SRM file
            # (highly unlikely), simply append the line at the end
            # of the list, using the appropriate level, of course:
            else:
                self.lines_list.append(SRMLine(line.level, tag, value))

    def delete_branch(self, index):
        """Delete branch (or line, if no children) at index."""
        if self.in_range(index):
            limit = self.get_last_offspring_index(index)
            if self.in_range(limit):
                newlist = self.lines_list[0:index] + self.lines_list[limit+1:]
                self.lines_list = newlist

    def get_colon_alignment_value(self, index):
        """Surveys the tag string lengths of following lines that
        will be printed consecutively at the same level to return
        the longest tag string of the group.  This value is then
        passed on to the SRMLine::print() to align the colons and
        values for a more pleasing printout.

        :param index: This parameter identifies the starting point
           for consideration of tag string lengths.
        """

        limit = self.get_line_count()
        max_tag_len = 0
        ref_line = self.lines_list[index]
        ref_level = ref_line.level

        index += 1
        while index < limit:
            new_line = self.lines_list[index]
            if new_line.level == ref_level:
                max_tag_len = max(max_tag_len, new_line.tag_len())
            else:
                break

            index += 1

        return max_tag_len

    def display(self, starts_at=0):
        """Print out the contents of the SRMFile.  If a starting point
        is indicated, only print the contents of that item."""
        i = starts_at
        if starts_at > 0:
            # Use line following last offspring as non-inclusive limit
            limit = 1 + self.get_last_offspring_index(starts_at)
        else:
            limit = self.get_line_count()

        last_line_level = 0
        group_max_tag_len = self.get_colon_alignment_value(0)

        while i < limit:
            line = self.lines_list[i]

            if line.level > last_line_level:
                group_max_tag_len = self.get_colon_alignment_value(i)
            elif line.level < last_line_level:
                group_max_tag_len = 0

            line.display(group_max_tag_len)

            last_line_level = line.level
            i += 1

    def seek_line_index(self, pstep, index=-1):
        """Seeks an SRMLine that matches the PStep specification,
        returning the index of the match, or -1 if no match was found.

        :param pstep: Is a PStep tree.
        :param index: Is the index of the line the current search begins.
        :return: Index of matching line, or -1 if no match exists.

        This function recurses along with the steps of the PStep
        tree.  The search procedes through each child if the indicated
        parent, checking each child's children according to the next_step
        data member of the current PStep.
        """
        if index == -1:
            level = 0
        elif self.in_range(index):
            level = self.get_unchecked_line_at(index).level + 1
        else:
            raise SRMFileRangeError("seek_line_index out of range.")

        for ndx in range(index+1, self.get_line_count()):
            line = self.get_unchecked_line_at(ndx)
            # Ignore comments and sub-children:
            if line.is_comment() or line.level > level:
                continue
            # Abandon search upon encountering earlier generation:
            elif line.level < level:
                return -1
            elif line.matches_pstep(pstep):
                # Confirm predicates, if any, by recursion
                pred_failed = False
                for predicate in pstep.predicates:
                    pred_failed = not self.confirm_line_index(predicate, ndx)
                    if pred_failed:
                        break

                # Try next sibling
                if pred_failed:
                    continue
                elif pstep.next_step is not None:
                    # Recurse for following steps
                    return self.seek_line_index(pstep.next_step, ndx)
                else:
                    return ndx

    def confirm_line_index(self, pstep, index=-1):
        """Shortcut function to confirm the existence of a matching line.
        This method is used to test predicate expressions that must only
        check for the existence of the line specified in the expression."""
        return self.seek_line_index(pstep, index) >= 0

def set_ansi_message_color(text=None):
    """Prints a line with ansi console code to change foreground color.
    If a text parameter is included, it will be added just after the color
    change as a separator from normal output."""
    print("[32m", end="")

    if text is not None:
        print(text)

def set_ansi_default_color(text=None):
    """Prints a line with ansi console code to return to normal foreground color.
    If a text parameter is included, it will be added just before the color
    change as a separator from normal output."""

    if text is not None:
        print(text)

    print("[0m", end="")


# The following functions are of the form "do_" plus an action name.
# They can be called by execute_arglist()
def do_last_child(srmfile, content_list=None):
    """Command Line action that adds a line as the last
    child of the branch indicated by the srm path string."""
    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                for line in content_list[1:]:
                    srmfile.append_after_last_child(index, line)
                    index = index + 1

def do_before_sibling(srmfile, content_list=None):
    """Command Line action that adds a line just before and at
    the same level as the branch indicate by the srm path string."""
    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                for line in content_list[1:]:
                    srmfile.insert_before_sibling(index, line)
                    index = index + 1

def do_after_sibling(srmfile, content_list=None):
    """Command Line action that adds a line just after and at
    the same level as the branch indicate by the srm path string."""
    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                for line in content_list[1:]:
                    srmfile.insert_after_sibling(index, line)
                    index = index + 1

def do_delete(srmfile, content_list=None):
    """Command line action that removes a branch from the SRMFile."""
    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                srmfile.delete_branch(index)

def do_display(srmfile, content_list=None):
    """Command Line action that will display the implied SRMFile
    tree ath the branch indicated by the srm path string.

    Use this action to isolate output to illustrate or confirm
    changes."""
    index = 0
    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)

    srmfile.display(index)

# Must accept unused srmfile argument because the
# call to this function is automatically generated.
# pylint: disable=unused-argument
def do_pause(srmfile, content_list=None):
    """Pause, with optional message, until the user presses ENTER."""
    set_ansi_message_color(".")

    if content_list and len(content_list) > 0:
        for msg in content_list:
            print(msg)

    input("Press ENTER to continue.")
    set_ansi_default_color(".")
# pylint: enable=unused-argument

# Must accept unused srmfile argument because the
# call to this function is automatically generated.
# pylint: disable=unused-argument
def do_message(srmfile, content_list=None):
    """Display a message in output.  Used for demonstration purposes."""
    if content_list and len(content_list) > 0:
        set_ansi_message_color(".")

        for msg in content_list:
            print(msg)

        set_ansi_default_color(".")
# pylint: enable=unused-argument

def show_actions(with_docs=False):
    """Reads module to find functions that start with 'do_'.
    The functions list is displayed with or without documentation
    according to the setting of parameter 'with_docs'."""
    thismod = sys.modules[__name__]
    for elname in dir(thismod):
        obj = getattr(thismod, elname)
        if isinstance(obj, types.FunctionType):
            if elname.startswith("do_"):
                print(elname[3:])

                if with_docs:
                    set_ansi_message_color()
                    if obj.__doc__:
                        print(obj.__doc__)
                    else:
                        print("Documentation missing")
                    set_ansi_default_color()

                    print()
def show_usage():
    """Show command usage upon request or after a mistake."""
    msg = """
Usage:
    gensfw_srm <filename> [ <action> <argument>... ] [ -- <action> <argument>... ]
    gensfw_srm --help
    gensfw_srm --show_actions
    gensfw_srm --show_action_docs

Options:
    --help, -h          This page
    --show_actions      Display the list of available actions.
    --show_action_docs  Display list of actions with explanations.
"""
    print(msg)

def execute_arglist(srmfile, arglist):
    """Looks for suitable function to execute, executing it if found."""
    if len(arglist) > 0:
        cur_action = "do_" + arglist[0].replace("-", "_")
        cur_function = getattr(sys.modules[__name__], cur_action)
        if cur_function:
            cur_function(srmfile, arglist[1:])

def process_args(srmfile):
    """Iterate through command line arguments, collecting into groups
    delimited by '--' arguments.  Each group is submitted to function
    execute_arglist()."""
    arglist = []
    # skip argv[1], which was an SRM filepath
    for arg in sys.argv[2:]:
        if arg == "--":
            execute_arglist(srmfile, arglist)
            arglist = []
        else:
            arglist.append(arg)

    if len(arglist):
        execute_arglist(srmfile, arglist)

def main():
    """Main program function."""
    srm_file = SRMFile()
    if len(sys.argv) < 2:
        show_usage()
        sys.exit(0)
    elif sys.argv[1].startswith("-"):
        option = sys.argv[1][1:]
        if option == "-help" or option == "h":
            show_usage()
        elif option == "-show_actions":
            show_actions()
        elif option == "-show_action_docs":
            show_actions(True)
        sys.exit(0)
    else:
        try:
            srm_file.initialize(sys.argv[1])
            process_args(srm_file)
        except PStepError as exception:
            print(exception)
        except SRMFileError as exception:
            print("The first parameter must be a path to a valid SRM file (%s)" % exception)

if __name__ == "__main__":
    main()

#!/usr/bin/env python3
""" Tool for modifying SRM files

This tool allows a user to make changes to an SRM file with command line
options.  Its purpose is to modify gensfw-generated scripts to illustrate
Schema Framework concepts and to make installation changes.

gensfw_es <filename>
"""
import sys
import types

# pylint: disable=too-many-lines
# pylint: disable=too-many-public-methods
# pylint: disable=too-many-branches

class PStepError(Exception):
    """Raised for any parsing path error."""
    def __init__(self, message=None):
        super().__init__(message)

class SRMFileError(Exception):
    """Raised for any SRM file parsing error."""
    def __init__(self, message=None):
        super().__init__(message)

class SRMFileRangeError(SRMFileError):
    """Raised when an invalid range index is used."""
    def __init__(self, message=None):
        super().__init__(message)

class SRMFilePathNotFound(SRMFileError):
    """Raised when a required SRMPath is not found."""
    def __init__(self, message=None):
        super().__init__(message)

class SRMFileBreak(SRMFileError):
    """Raised when a 'break_if' action finds the SRM line."""
    def __init__(self, message=None):
        super().__init__(message)

class SRMUnknownAction(Exception):
    """Exception class to notify of unrecognized action."""
    def __init__(self, message=None):
        super().__init__(message)

class SRMGotoTarget(Exception):
    """Raised by "goto" action, if SRMPath confirmed, to name target label."""
    def __init__(self, message=None):
        super().__init__(message)

def parse_srm_line(linestr):
    """Returns a (tag, value) tuple from an SRM file line,
    in which the values are both trimmed of leading and
    trailing spaces."""
    linestr = linestr.strip()
    tag = None
    value = None

    if len(linestr) > 0:
        if linestr[0] == "#":
            tag = linestr
        else:
            parts = linestr.split(":", 1)
            tag = parts[0].strip()
            if len(parts) > 1:
                value = parts[1].strip()

    return (tag, value)

def find_named_label_action(name):
    """Returns the sys.argv index of a label action, or -1 if not found.

    This function is used in a "goto" action to locate the index of the
    label referenced by the "goto" action."""

    index = 2
    limit = len(sys.argv)

    for arg in sys.argv[2:]:
        if arg == "label":
            if (index+1 < limit
                    and sys.argv[index+1] == name
                    and (index == 2
                         or sys.argv[index-1] == "--")):
                return index

        index += 1

    return -1

class PStep:
    """A linked class that identifies an acceptable match
    for a line in an SRM file."""

    # Class variable to check for balanced braces.
    brace_level = 0

    def __init__(self, stepstring, starts_with=None):
        self.starts_with = starts_with
        self.tag = None
        self.value = None
        self.predicates = []
        self.next_step = None

        self.initialize_step_parts(step_part_generator(stepstring))

    @staticmethod
    def braces_balanced():
        """Returns True if number of close and open braces are equal."""
        return PStep.brace_level == 0

    def node_test_set(self):
        """Boolean function returning initialization status."""
        return self.tag is not None

    def set_node_test(self, node_test):
        """Initializes the non-predicate part of the step."""
        self.tag, self.value = parse_srm_line(node_test)

    def node_test_str(self):
        """Builds a node_test string from the current state of the object."""

        if self.value:
            return "%s : %s" % (self.tag, self.value)
        elif self.tag:
            return self.tag
        else:
            return "unassigned"

    def initialize_predicate_objects(self, parray):
        """Populate the member array with PStep objects.

        Create new PStep objects to install into the object's predicate
        array from the array of predicate expressions."""

        for pred_exp in parray:
            self.predicates.append(build_pstep(pred_exp))

    def initialize_step_parts(self, generator):
        """Uses output from step_part_generator() to build PStep.
        """

        node_test_done = False
        pred_exp_list = []
        for pstr, ptype in generator:
            if not node_test_done:
                if ptype != "nt":
                    raise PStepError("Confused step part, we should be "
                                     "reading a node_test string here "
                                     "(%s)." % pstr)
                self.set_node_test(pstr)
                node_test_done = True
            else:
                pred_exp_list.append(pstr)
                if ptype != "pe":
                    raise PStepError("Confused step part, we should be "
                                     "reading a predicate expression "
                                     "here (%s)." % pstr)

        if len(pred_exp_list) > 0:
            self.initialize_predicate_objects(pred_exp_list)

    def has_predicate(self):
        """Boolean test for existence of predicates.  Used mostly
        to communicate the intention of the code, that is, to make
        more clear the 'if' statement that calls it."""
        return len(self.predicates) > 0

    def __str__(self):
        """Override default __str__ function."""
        alist = [self.node_test_str()]
        for pred in self.predicates:
            alist.append("[%s]" % pred)
        if self.next_step is not None:
            alist.append("/%s" % self.next_step)

        return "".join(alist)

    def dump(self, stepnum=1, level=0):
        """Prints out a representation of the PStep with its links.
        It is meant to be used for debugging how a SRM path is
        evaluated."""
        indent = ('  ' * level)
        print("%sstep %d, node_test: %s"
              % (indent, stepnum, self.node_test_str()))
        if len(self.predicates):
            level += 1
            indent = ("  " * level)
            for pred in self.predicates:
                print("%s[" % indent)
                pred.dump(1, level+1)
                print("%s]" % indent)

        if self.next_step is not None:
            self.next_step.dump(stepnum+1, level)


def read_path_string(path_string):
    """Generator function that allows parsing of a path string
    with a single pass through its characters.  It yields a
    tuple with a string and the character that signalled the
    string's end.

    This generator is used by the PStep class, especially the
    parse method of the PStep class."""

    buff = []

    for char in path_string:
        if char in "[]/":
            yield ("".join(buff), char)
            buff = []
        else:
            buff.append(char)

    # Flush the buffer (final step without terminating token)
    if len(buff):
        yield ("".join(buff), None)

def step_generator(pathstr):
    """Break a path string into discrete steps.

    The step generator returns each step of an SRM Path expression,
    as marked by a '/' character, exclusive of the step contents of
    predicates, if any."""
    buffer = []
    level = 0
    for char in pathstr:
        if char == '/' and level == 0:
            yield "".join(buffer)
            buffer = []
        else:
            buffer.append(char)
            if char == '[':
                level += 1
            elif char == ']':
                level -= 1
                if level < 0:
                    raise PStepError("Unbalanced Braces "
                                     "([1;31m%s[0m)"
                                     % "".join(buffer))

    yield "".join(buffer)

def step_part_generator(stepstr):
    """Break a step string into discrete parts.

    We do not check for balanced braces here because the
    stepstr, having come from the step_generator(), has
    already been checked for balanced braces."""

    buffer = []
    node_test = False
    level = 0
    for char in stepstr:
        if char == '[':
            level += 1
            if level == 1:  # entered at level == 0
                if not node_test:
                    node_test = True
                    yield ("".join(buffer), "nt")
                    buffer = []
                # Don't save predicate delimiters at step level
                continue
        elif char == ']':
            level -= 1
            if level == 0:
                yield ("".join(buffer), "pe")
                buffer = []
                # Don't save predicate delimiters at step level
                continue

        buffer.append(char)

    if len(buffer) > 0:
        if not node_test:
            yield ("".join(buffer), "nt")
        else:
            raise PStepError("Error parsing step string '%s'" % stepstr)

def build_pstep(pathstr):
    """Global command to build a PStep tree from a pathstr."""

    pstep_head = None
    pstep_tail = None

    def read_steps(gen):
        """Process each generated step."""
        for stepstr in gen:
            nonlocal pstep_head
            nonlocal pstep_tail

            # Disable warning, pylint3 not recognizine nonlocal
            # pylint: disable=used-before-assignment
            new_pstep = PStep(stepstr)
            if pstep_head is None:
                pstep_head = pstep_tail = new_pstep
            else:
                pstep_tail.next_step = new_pstep
                pstep_tail = new_pstep
            # pylint: enable=used-before-assignment

    read_steps(step_generator(pathstr))

    return pstep_head


class SRMLine:
    """Represents a single line of an SRM file that contains
    values for the level of the line and values for the tag
    and value parts of the SRM line."""
    def __init__(self, level=0, tag=None, value=None):
        self.level = level
        self.tag = tag
        self.value = value

    def __str__(self):
        """Override default __str__ function."""
        if self.tag:
            parts = [self.tag]
            if self.value and len(self.value) > 0:
                parts.append(" : %s" % self.value)
            return "".join(parts)
        else:
            return ""

    @staticmethod
    def make_copy(srmline):
        """Make copy (since we can't have a copy constructor in Python."""
        return SRMLine(srmline.level, srmline.tag, srmline.value)

    def copy_from(self, srmline):
        """Concession to python's lack of support of a copy constructor."""
        self.level = srmline.level
        self.tag = srmline.tag
        self.value = srmline.value

    def is_comment(self):
        """Returns True if the line is a comment, False otherwise."""
        return self.tag and len(self.tag) > 0 and self.tag[0] == "#"

    def has_value(self):
        """Returns True if value property is not None."""
        return self.value is not None

    def is_empty(self):
        """Returns True for an empty line, False otherwise."""
        return self.tag is None

    def is_content(self):
        """Returns True if the line is a content line, False otherwise.
        A content line is a non-comment line that has at least a tag value."""
        return not (self.is_comment() or self.is_empty())

    def display(self,
                colon_align=None,
                outfile=sys.stdout,
                level_offset=0):
        """Prints the line according to its contents.

        :param colon_align: Setting this optional parameter
           will pad the printout of the *tag* value to align
           the colon for a more pleasing-to-read output.
        :param output: A file opened for writing, to which the
           output will be sent.  If this parameter is omitted,
           the output will be sent to stdout.
        :param level_offset: The indentation level will be
           decreased by this number when printing sub-branches.

        This method prints 3 spaces per level, then the
        tag.  If the line includes a value, a comma and the
        value string will be printed following the tag."""

        lev = self.level - level_offset
        if lev > 0:
            print("   " * lev, end="", file=outfile)

        if self.tag:
            print(self.tag, end="", file=outfile)
            if self.value:
                if colon_align:
                    colon_spaces = " " * (colon_align - self.tag_len())
                    print(colon_spaces, end="", file=outfile)

                print(" : %s" % self.value, end="", file=outfile)

        print(file=outfile)

    def tag_len(self):
        """This method returns the length of the tag value,
        unless the line is a comment type, in which case the
        tag_len will be 0.
        """

        if self.tag and not self.is_comment():
            return len(self.tag)
        else:
            return 0

    def matches_pstep(self, pstep):
        """Returns True if the line matches the pstep specs.

        Comments cannot be matched and always return False.

        IMPORTANT NOTE:
        The existence of a '!' prefix will be ignored.  If found,
        the comparison will be with the tag with the '!' prefix
        removed.

        The '!' prefix will be considered when processing a
        predicate expression, where the '!' will toggle the
        boolean value.
        """

        if self.is_comment() or pstep.tag is None:
            return False

        tag = pstep.tag
        if tag[0] == '!':
            tag = tag[1:]

        if tag == self.tag or tag == "*":
            return pstep.value is None or pstep.value == self.value
        else:
            return False

class SRMLineParser:
    """Parses lines of an SRM file, creating an SRMLine object
    that can then be added to an SRMFile.

    The best use of an SRMLineParser object is to use a single
    instance to parse all the lines of an SRM file.  The parser
    tracks consecutive lines to deduce the intended level, so
    using a new SRMLineParser to process different lines will
    hinder the object's ability to recognize levels.
    """

    level_stops = [0]
    lines_parsed = 0
    bad_level_msg = ("Spaces count in line not "
                     "previously used in current "
                     "branch.")

    def __init__(self):
        self.level_stops = [0]
        self.lines_parsed = 0

    def cur_level_spaces(self):
        """Returns the current inferred level value of the
        current line based on the number of spaces that precede
        tag of this and previous SRM lines."""
        return self.level_stops[-1]

    def get_level_from_spaces_count(self, spaces_count):
        """This method deduces the current line's hierachical
        level based on the number of leading spaces of consecutive
        lines and a persistent record of the indentation level of
        previous level definitions.

        Possible "Bad Level" Exception
        ------------------------------

        This method may raise an exception if the levels are disordered.
        Confusion occurs when the indentation of a line decreases from
        the previous line to a greater indentation level than the new
        lines parent line.

        The following shows a disordered indentation:

        edit
           procedure   : App_Item_Update
           schema_proc : App_Item_Value
           schema
              button
                 type : add
                label : Add
              button
                 type : delete
                 label : Delete


        Notice the two lines under the first *button*.  The *type : add*
        and *label : Add* lines look to be siblings under the *button*
        parent line, but since the indentation levels are not consistent,
        the appropriate level can only be guessed.

        This type of error can be much less obvious if the siblings are
        separated by many lines of code.
        """
        if spaces_count > self.cur_level_spaces():
            self.level_stops.append(spaces_count)
            return len(self.level_stops) - 1
        elif spaces_count == self.cur_level_spaces():
            return len(self.level_stops) - 1
        else:
            # backing down levels, must be in level_stops:
            while self.level_stops[-1] > spaces_count:
                self.level_stops.pop()

            if self.level_stops[-1] == spaces_count:
                return len(self.level_stops) - 1
            else:
                raise SRMFileError(self.bad_level_msg)

    def parse_line(self, line):
        """Returns an SRMLine object by interpreting the 'line'
        parameter in the context of the preceding lines in the
        SRM file."""
        self.lines_parsed += 1
        sline = line.lstrip()
        spaces = len(line) - len(sline)

        level = self.get_level_from_spaces_count(spaces)
        tag = None
        value = None

        if len(sline):
            tag, value = parse_srm_line(sline)
        else:
            # Override level for a blank line
            level = 0

        return SRMLine(level, tag, value)

class SRMFile:
    """This class contains the parsed contents of an SRM file."""

    lines_list = []
    def __init__(self, filepath=None):
        self.lines_list = []
        if filepath != None:
            self.initialize(filepath)

    def initialize(self, filepath):
        """Parses all lines contained in the file to create a
        list of SRMLines."""
        self.lines_list = []
        with open(filepath) as fileobj:
            parser = SRMLineParser()
            for line in fileobj:
                self.lines_list.append(parser.parse_line(line.rstrip()))

    def get_line_count(self):
        """Returns number of lines in the list for creating a range."""
        return len(self.lines_list)

    def in_range(self, index):
        """Boolean function that confirms or refutes that a index number
        represents an existing line in the lines_list."""
        return index >= 0 and index < self.get_line_count()

    def level_at_index_inclusive(self, index):
        """Returns the inferred tree level of an SRMLine at the index.
        This method is used to compare the relationship of consecutive
        lines to identify siblings and the end of a run of siblings.

        Comments and empty lines are valid in this method and will
        return an implied tree level according to normal rules."""
        if self.in_range(index):
            return self.lines_list[index].level
        else:
            return -1

    def level_at_index(self, index):
        """Returns the inferred tree level of an SRMLine at the index,
        including only instruction lines.  That is, it will return -1
        if the line is comment or is empty."""
        if self.in_range(index):
            line = self.lines_list[index]
            if line.is_comment() or line.is_empty():
                return -1
            else:
                return line.level
        else:
            return -1

    def is_content_at_index(self, index):
        """Returns is_content() result for SRMLine at index."""
        return self.in_range(index) and self.lines_list[index].is_content()

    def is_empty_at_index(self, index):
        """Returns is_empty() result for SRMLine at index."""
        return self.in_range(index) and self.lines_list[index].is_empty()

    def get_unchecked_line_at(self, index):
        """Unconditionally return an SRM line from the lines_list as
        indicated by the index parameter.  Use this function instead
        of the safer 'get_line_at' when the index has already been
        confirmed."""
        return self.lines_list[index]

    def get_line_at(self, index):
        """Return an SRM line from the lines_list as indicated by
        the index parameter.  Returns None if the index is out of
        range."""
        if self.in_range(index):
            return self.get_unchecked_line_at(index)
        else:
            return None

    def get_first_child_index(self, index):
        """Get first child line of SRMLine at index."""
        if self.in_range(index):
            line = self.get_unchecked_line_at(index)
            level = line.level + 1
            for ndx in range(index+1, self.get_line_count()):
                line = self.get_unchecked_line_at(ndx)
                if line.level > level:
                    continue
                elif line.level < level:
                    break
                elif not line.is_comment():
                    return ndx

        return -1

    def get_last_child_index(self, index):
        """Get last child line of SRMLine at index."""
        lastchild = -1
        if self.in_range(index):
            line = self.get_unchecked_line_at(index)
            level = line.level + 1
            for ndx in range(index+1, self.get_line_count()):
                line = self.get_unchecked_line_at(ndx)
                if line.level < level:
                    break
                elif (line.level > level
                      or line.is_comment()
                      or line.is_empty()):
                    continue
                else: # line.level == level
                    lastchild = ndx

        return lastchild

    def get_last_offspring_index(self, index):
        """Returns the line index of the last line whose ancestor
        is the reference line."""

        lastoffspring = -1
        origin_level = self.level_at_index(index)
        last_line = self.get_line_count()

        if self.in_range(index):
            line = self.get_unchecked_line_at(index)
            level = line.level + 1
            for ndx in range(index+1, last_line):
                line = self.get_unchecked_line_at(ndx)
                if line.level <= origin_level:
                    break
                elif (line.is_comment() or line.is_empty()):
                    continue
                elif (line.level > origin_level):
                    lastoffspring = ndx

        return lastoffspring

    def get_copy_at_pstep(self, pstep):
        """Returns new list of SRMLine elements of the specified branch."""

        index = self.seek_line_index(pstep)
        newlist = []
        if index >= 0:
            srmline = self.get_line_at(index)
            base_level = srmline.level
            newline = SRMLine.make_copy(srmline)
            newline.level -= base_level
            newlist.append(newline)

            def gen(levlimit, start):
                """quick-and-dirty srmline generator."""
                for srmline in self.lines_list[start:]:
                    if srmline.level > levlimit:
                        yield srmline
                    else:
                        break

            for srmline in gen(base_level, index+1):
                newline = SRMLine.make_copy(srmline)
                newline.level -= base_level
                newlist.append(newline)

        return newlist

    def insert_srmline_list_at(self,
                               srmline_list,
                               position=0,
                               level=None,
                               contents_only=False):
        """Copies contents of srmline_list into SRMFile.

        The new lines will be inserted before the SRMLine referenced by
        the position parameter (or at the end if position < 0).  The level
        value of the new lines will be increased by the value in the
        level parameter.
        """

        if level is None:
            level = self.level_at_index(position) + 1

        def app(line):
            """closure function"""
            self.lines_list.append(line)

        def ins(line):
            """closure function"""
            nonlocal position
            self.lines_list.insert(position, line)
            position += 1

        if position < 0:
            adder = app
        else:
            adder = ins

        start = 0

        # If we're GOing TO the head, we need to adjust the starting
        # index and the promote the level of the contents by one level.
        if contents_only:
            start = 1
            level -= 1

        for line in srmline_list[start:]:
            line.level += level
            adder(line)

    def insert_as_first_child(self, index, linestr):
        """Splicing function to insert a new line as a child immediately after
        the line at the indicated position.  The 'linestr' string will be
        parsed for tag and value, and the level of the new SRMLine will match
        that of the last child."""

        tag, value = parse_srm_line(linestr)
        # Determine new item level as 1 greater than the parent node:
        level = self.level_at_index(index)
        newline = SRMLine(level+1, tag, value)

        index += 1

        if self.in_range(index):
            self.lines_list.insert(index, newline)
        else:
            self.lines_list.append(newline)

    def append_after_last_child(self, index, linestr):
        """Splicing function to insert a new line at the indicated position.
        The 'linestr' string will be parsed for tag and value, and the level
        of the new SRMLine will match that of the last child."""

        tag, value = parse_srm_line(linestr)
        # Determine new item level as 1 greater than the parent node:
        level = self.level_at_index(index)
        newline = SRMLine(level+1, tag, value)

        ndx = self.get_last_offspring_index(index)

        if ndx < 0:
            ndx = index + 1
        else:
            ndx += 1

        if self.in_range(ndx):
            self.lines_list.insert(ndx, newline)
        else:
            self.lines_list.append(newline)

    def insert_before_sibling(self, index, linestr):
        """Insert a new SRMLine just before, and
        at the same level as the indicated line."""

        if self.in_range(index):
            tag, value = parse_srm_line(linestr)
            level = self.level_at_index(index)
            self.lines_list.insert(index,
                                   SRMLine(level, tag, value))

    def insert_after_sibling(self, index, linestr):
        """Insert a new SRMLine just after, and
        at the same level as the indicated line."""

        if self.in_range(index):
            tag, value = parse_srm_line(linestr)
            level = self.level_at_index(index)

            ndx = self.get_last_offspring_index(index)

            if ndx < 0:
                ndx = index

            if self.in_range(ndx+1):
                self.lines_list.insert(ndx+1,
                                       SRMLine(level, tag, value))
            else:
                self.lines_list.append(SRMLine(level, tag, value))

    def append_mode(self, linestr):
        """Create a mode line at the end of the srmfile."""

        tag, value = parse_srm_line(linestr)
        self.lines_list.append(SRMLine(0, tag, value))

    def delete_branch(self, index):
        """Delete branch (or line, if no children) at index."""
        if self.in_range(index):
            limit = self.get_last_offspring_index(index)
            if self.in_range(limit):
                newlist = self.lines_list[0:index] + self.lines_list[limit+1:]
                self.lines_list = newlist

    def get_colon_alignment_value(self, index):
        """Surveys the tag string lengths of following lines that
        will be printed consecutively at the same level to return
        the longest tag string of the group.  This value is then
        passed on to the SRMLine::print() to align the colons and
        values for a more pleasing printout.

        :param index: This parameter identifies the starting point
           for consideration of tag string lengths.
        """

        limit = self.get_line_count()
        max_tag_len = 0

        if index < limit:
            ref_line = self.lines_list[index]
            ref_level = ref_line.level

            index += 1
            while index < limit:
                new_line = self.lines_list[index]
                if new_line.level == ref_level:
                    max_tag_len = max(max_tag_len, new_line.tag_len())
                else:
                    break

                index += 1

        return max_tag_len

    def display(self, starts_at=0, skip_comments=False, outfile=sys.stdout):
        """Print out the contents of the SRMFile.  If a starting point
        is indicated, only print the contents of that item.

        :param skip_comments: If this flag is set, comment lines will be
           skipped.
        :param outfile: If set, this parameter should be a file stream
           opened for writing, and the output will be written to this
           file stream."""

        loffset = 0

        i = starts_at
        if starts_at > 0:
            loffset = self.level_at_index(starts_at)

            # Use line following last offspring as non-inclusive limit
            limit = self.get_last_offspring_index(starts_at)
            if limit == -1:
                limit = self.get_line_count()
            else:
                limit += 1
        else:
            limit = self.get_line_count()

        last_line_level = 0
        group_max_tag_len = self.get_colon_alignment_value(0)

        while i < limit:
            line = self.lines_list[i]

            if line.level > last_line_level:
                group_max_tag_len = self.get_colon_alignment_value(i)
            elif line.level < last_line_level:
                group_max_tag_len = 0

            if not skip_comments or not line.is_comment():
                line.display(group_max_tag_len,
                             outfile,
                             level_offset=loffset)

            last_line_level = line.level
            i += 1

    def seek_line_index(self, pstep, index=-1):
        """Seeks an SRMLine that matches the PStep specification,
        returning the index of the match, or -1 if no match was found.

        :param pstep: Is a PStep tree.
        :param index: Is the index of the line the current search begins.
        :return: Index of matching line, or -1 if no match exists.

        This function recurses along with the steps of the PStep
        tree.  The search procedes through each child if the indicated
        parent, checking each child's children according to the next_step
        data member of the current PStep.
        """

        if index == -1:
            level = 0
        elif self.in_range(index):
            level = self.get_unchecked_line_at(index).level + 1
        else:
            raise SRMFileRangeError("seek_line_index out of range.")

        for ndx in range(index+1, self.get_line_count()):
            line = self.get_unchecked_line_at(ndx)

            if line.is_comment() or line.is_empty() or line.level > level:
                continue
            elif line.level < level:
                # Abandon search upon encountering earlier generation:
                return -1
            elif line.matches_pstep(pstep):
                # Confirm predicates, if any, by recursion
                pred_failed = False
                for predicate in pstep.predicates:
                    if predicate.tag[0] == '!':
                        pred_failed = self.confirm_line_index(predicate, ndx)
                    else:
                        pred_failed = not self.confirm_line_index(predicate, ndx)

                    if pred_failed:
                        break

                # Try next sibling
                if pred_failed:
                    continue
                elif pstep.next_step is not None:
                    index = self.seek_line_index(pstep.next_step, ndx)
                    if index >= 0:
                        return index
                    else:
                        continue
                else:
                    return ndx

        return -1

    def get_matching_lines(self, pstep, index=-1):
        """Returns list of lines matching the pstep argument."""

        return_list = []

        if index == -1:
            level = 0
        elif self.in_range(index):
            level = self.get_unchecked_line_at(index).level + 1
        else:
            raise SRMFileRangeError("seek_line_index out of range.")

        for ndx in range(index+1, self.get_line_count()):
            line = self.get_unchecked_line_at(ndx)

            if line.is_comment() or line.is_empty() or line.level > level:
                continue
            elif line.level < level:
                # Abandon search upon encountering earlier generation:
                break
            elif line.matches_pstep(pstep):
                # Confirm predicates, if any, by recursion
                pred_failed = False
                for predicate in pstep.predicates:
                    if predicate.tag[0] == '!':
                        pred_failed = self.confirm_line_index(predicate, ndx)
                    else:
                        pred_failed = not self.confirm_line_index(predicate, ndx)

                    if pred_failed:
                        break

                # Try next sibling
                if pred_failed:
                    continue
                elif pstep.next_step is None:
                    return_list.append(ndx)
                else:
                    sub_list = self.get_matching_lines(pstep.next_step, ndx)
                    if len(sub_list) > 0:
                        return_list.extend(sub_list)
                        continue

        return return_list

    def confirm_line_index(self, pstep, index=-1):
        """Shortcut function to confirm the existence of a matching line.
        This method is used to test predicate expressions that must only
        check for the existence of the line specified in the expression."""
        return self.seek_line_index(pstep, index) >= 0

    def seek_line_at_path(self, srmpath):
        """Shortcut function to return line at path, or None."""

        pstep = build_pstep(srmpath)
        index = self.seek_line_index(pstep)
        if index:
            return self.get_unchecked_line_at(index)
        else:
            return None

    # end of class SRMFile

def set_ansi_message_color(text=None):
    """Prints a line with ansi console code to change foreground color.
    If a text parameter is included, it will be added just after the color
    change as a separator from normal output."""
    print("[1;32m", end="")

    if text is not None:
        print(text)

def set_ansi_default_color(text=None):
    """Prints a line with ansi console code to return to normal foreground color.
    If a text parameter is included, it will be added just before the color
    change as a separator from normal output."""

    if text is not None:
        print(text)

    print("[0m", end="")

def get_local_function(name):
    """Seek for, and return if found, function indicated by 'name'."""

    def missing_local_function():
        """Closure function for return value alert missing function."""
        print("Function '%s' is not defined." % name)

    mainm = sys.modules["__main__"]
    flist = dir(mainm)
    if flist.count(name) == 1:
        return getattr(mainm, name)
    else:
        return missing_local_function

# pylint: disable=unused-argument
def msg_cmd_clrscr(srmfile, data):
    """Clear screen."""
    print("[2J[1;1H", end="")
# pylint: enable=unused-argument

def msg_cmd_show(srmfile, data):
    """Write out indicated lines, whole or in part.

    The message syntax, described by example:
    <%show:path>      show the first line matching the path
    <%show:path^t)    show the tag of the first line matching the path
    <%show:path^v)    show the value of the first line matching the path
    <%show:path1|path2|path3>  show the lines of each of the three paths

    The default output delimiter is '|', but it can be changed by
    including a single character before the first '|' input delimiter.
    For example, to use a # delimiter:
    <%show:#|path1|path2|path3>
"""

    specs = data.split('|')
    delimiter = '|'

    if len(specs) > 0 and len(specs[0]) < 2 and specs[0] != '*':
        delimiter = specs[0]
        specs = specs[1:]

    output = []
    for spec in specs:
        parts = spec.split('^', 1)
        path = parts[0]
        flag = None if len(parts) == 1 else parts[1]

        srmline = srmfile.seek_line_at_path(path)
        if srmline and not srmline.is_empty():
            if flag == 't':
                output.append(srmline.tag)
            elif flag == 'v':
                output.append(srmline.value)
            else:
                value = "" if not srmline.has_value() else ":"+srmline.value
                output.append("%s%s" % (srmline.tag, value))

    if len(output) > 0:
        print(delimiter.join(output))
    else:
        print("N/A")

# pylint: disable=unused-argument
def msg_cmd_color(srmfile, data):
    """Set ANSI color value for subsequent output.

    syntax:
    <%color:COLOR>
    where COLOR can be one of the following:
       red
       green
       brown
       blue
       magenta
       cyan
       white
       reset   (return to default color)

    If you use colors, make sure you use <%color:reset> if you've
    previously set another color.
"""

    val = None
    if data == "red":
        val = 31
    elif data == "green":
        val = 32
    elif data == "brown":
        val = 33
    elif data == "blue":
        val = 34
    elif data == "magenta":
        val = 35
    elif data == "cyan":
        val = 36
    elif data == "white":
        val = 37
    elif data == "reset":
        val = 0

    if val is not None:
        print("[1;%dm" % val, end="")

# pylint: enable=unused-argument

def process_message_cmd(srmfile, line):
    """Executes embedded commands in a message action.

    The syntax is '<%xxx>' where the command is introduced by
    '<%' and terminated by '>'.  The command must be the only
    content of the parameter in the message action."""

    content = line[2:-1]
    parts = content.split(":", 1)
    command = parts[0].lower()
    data = None if len(parts) == 1 else parts[1]
    fname = "msg_cmd_" + command
    get_local_function(fname)(srmfile, data)

def tweak_srmline_list(srmline_list, list_args):
    """Modify the list of srmline according to list_args.

    This function is called by several do_ actions:
       do_set_line
       do_copy_as_first_child
       do_copy_as_last_child
       do_copy_after_sibling
       do_copy_before_sibling

    For the first element of the srmline_list, <%SET_TAG> and
    <%SET_VALUE> changes the tag or value, respectively, to
    the string in the following argument.

    <%CONTENTS_ONLY> only makes sense for the do_copy_ functions,
    but it does remove the first line of srmline_list, even if it
    has only a single member, as would be the case for do_set_line.

    <%CONTENTS_ONLY> eliminates the first line, so changes attempted
    by <%SET_TAG> or <%SET_VALUE> will be lost.
"""

    setting_value = False
    setting_tag = False
    for arg in list_args:
        if setting_tag:
            srmline_list[0].tag = arg
            setting_tag = False
        elif setting_value:
            srmline_list[0].value = arg
            setting_value = False
        elif arg == "<%SET_TAG>":
            setting_tag = True
        elif arg == "<%SET_VALUE>":
            setting_value = True
        elif arg == "<%CONTENTS_ONLY>":
            newlist = srmline_list[1:]
            for line in newlist:
                line.level -= 1
            return newlist

    return srmline_list


# The following functions are of the form "do_" plus an action name.
# They can be called by execute_arglist()
def do_first_child(srmfile, content_list=None):
    """Command Line action that adds a line as the first
    child of the branch indicated by the srm path string.

    Syntax:
    first_child <target_location> <new line>"""
    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                for line in content_list[1:]:
                    srmfile.insert_as_first_child(index, line)

def do_last_child(srmfile, content_list=None):
    """Command Line action that adds a line as the last
    child of the branch indicated by the srm path string.

    Syntax:
    last_child <target_location> <new line>"""

    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                for line in content_list[1:]:
                    srmfile.append_after_last_child(index, line)

def do_before_sibling(srmfile, content_list=None):
    """Command Line action that adds a line just before and at
    the same level as the branch indicate by the srm path string.

    Syntax:
    before_sibling <target_location> <new line>"""

    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                for line in content_list[1:]:
                    srmfile.insert_before_sibling(index, line)
                    index = index + 1

def do_after_sibling(srmfile, content_list=None):
    """Command Line action that adds a line just after and at
    the same level as the branch indicate by the srm path string.

    Syntax:
    after_sibling <target_location> <new line>"""

    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                for line in content_list[1:]:
                    srmfile.insert_after_sibling(index, line)
                    index = index + 1

def do_append_mode(srmfile, content_list=None):
    """Add a mode (level-0 item) at the end of the srmfile."""
    if content_list and len(content_list) > 0:
        srmfile.append_mode(content_list[0])

def do_set_line(srmfile, content_list=None):
    """Modify line with options.

    There are three recognized tags:
    <%CONTENTS_ONLY>
       Deletes the first item in the the list, so only the offspring
       of the branch will be later copied.
    <%SET_TAG>
       Changes the tag of the root branch.  Ignored if <%CONTENTS_ONLY> used.
    <%SET_VALUE>
       Changes the value of the root branch.  Ignored if <%CONTENTS_ONLY> used.

    Syntax:
    set_line <target_location> <tag> <setting>

    Example:
    set_line "login/schema/button/label" "<%SET_VALUE>" "Register New User"
    """

    if content_list and len(content_list) > 1:
        pstep = build_pstep(content_list[0])
        index = srmfile.seek_line_index(pstep)
        if index >= 0:
            srmline = srmfile.get_unchecked_line_at(index)
            newlist = tweak_srmline_list([srmline], content_list[1:])
            if len(newlist) > 0:
                srmline.copy_from(newlist[0])

def do_break_if(srmfile, content_list=None):
    """Action to terminate processing arguments if the SRMPath is found.

    Use this action to confirm the state of an SRM file before performing
    some other action.

    Syntax:
    break_if <target-line-the-existance-of-which-triggers-action>"""

    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                print("Breaking out of 'do_break_it'")
                raise SRMFileBreak()

def do_copy_as_last_child(srmfile, content_list=None):
    """Copy a branch as a child after the last child of the target.

    Syntax:
    copy_as_last_child <target_location> <branch_to_copy> [options]

    See also \"do_set_line\" for an explanation of the options.
"""

    if content_list and len(content_list) > 1:

        pstep_left = build_pstep(content_list[0])
        left_index = srmfile.seek_line_index(pstep_left)

        if left_index < 0:
            raise SRMFilePathNotFound(content_list[0])

        left_line = srmfile.get_line_at(left_index)

        target_index = srmfile.get_last_offspring_index(left_index)
        if target_index <= 0:
            target_index = left_index + 1
        else:
            target_index += 1

        pstep_right = build_pstep(content_list[1])

        copy_of_right = srmfile.get_copy_at_pstep(pstep_right)
        copy_of_right = tweak_srmline_list(copy_of_right, content_list[2:])

        srmfile.insert_srmline_list_at(copy_of_right,
                                       target_index,
                                       left_line.level+1)

def do_copy_after_sibling(srmfile, content_list=None):
    """Copy a branch as sibling after target location.

    Syntax:
    copy_after_sibling <target_location> <branch_to_copy> [options]

    Example:
    copy_after_sibling login login <%SET_TAG> logout

    See also \"do_set_line\" for an explanation of the options.
"""

    if content_list and len(content_list) > 1:

        pstep_left = build_pstep(content_list[0])
        left_index = srmfile.seek_line_index(pstep_left)

        if left_index < 0:
            raise SRMFilePathNotFound(content_list[0])

        left_line = srmfile.get_line_at(left_index)

        target_index = srmfile.get_last_offspring_index(left_index) + 1
        if target_index <= 0:
            target_index = left_index + 1
        else:
            target_index += 1

        pstep_right = build_pstep(content_list[1])

        copy_of_right = srmfile.get_copy_at_pstep(pstep_right)
        copy_of_right = tweak_srmline_list(copy_of_right, content_list[2:])

        srmfile.insert_srmline_list_at(copy_of_right,
                                       target_index,
                                       left_line.level)

def do_copy_before_sibling(srmfile, content_list=None):
    """Copy a branch as sibling before target location.

    Syntax:
    copy_before_sibling <target_location> <branch_to_copy> [options]

    Example:
    copy_before_sibling login login <%SET_TAG> logout

    See also \"do_set_line\" for an explanation of the options.
"""

    if content_list and len(content_list) > 1:

        pstep_left = build_pstep(content_list[0])
        left_index = srmfile.seek_line_index(pstep_left)

        if left_index < 0:
            raise SRMFilePathNotFound(content_list[0])

        left_line = srmfile.get_line_at(left_index)
        pstep_right = build_pstep(content_list[1])

        copy_of_right = srmfile.get_copy_at_pstep(pstep_right)
        copy_of_right = tweak_srmline_list(copy_of_right, content_list[2:])

        srmfile.insert_srmline_list_at(copy_of_right,
                                       left_index,
                                       left_line.level)

def do_copy_as_first_child(srmfile, content_list=None):
    """Copy a branch as first child of target location.

    Syntax:
    copy_as_first_child <target_location> <branch_to_copy> [options]

    See also \"do_set_line\" for an explanation of the options.
"""

    if content_list and len(content_list) > 1:

        pstep_left = build_pstep(content_list[0])
        left_index = srmfile.seek_line_index(pstep_left)

        if left_index < 0:
            raise SRMFilePathNotFound(content_list[0])

        left_line = srmfile.get_line_at(left_index)
        pstep_right = build_pstep(content_list[1])

        copy_of_right = srmfile.get_copy_at_pstep(pstep_right)
        copy_of_right = tweak_srmline_list(copy_of_right, content_list[2:])

        srmfile.insert_srmline_list_at(copy_of_right,
                                       left_index+1,
                                       left_line.level+1)

def do_delete(srmfile, content_list=None):
    """Command line action that removes a branch from the SRMFile."""
    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        if pstep:
            index = srmfile.seek_line_index(pstep)
            if index >= 0:
                srmfile.delete_branch(index)

def do_display(srmfile, content_list=None):
    """Shows line or branch at indicate SRMPath.

    Use this action to isolate output to illustrate or confirm
    changes.

    There are two flag tokens for this action:
       - <%SKIP_COMMENTS> to omit comment lines from display.
       - <%SINGLE_LINE> to display the line without its children.
    """

    srmline_index = 0
    skipping_comments = False
    single_line = False

    if content_list and len(content_list) > 0:
        for arg in content_list:
            if arg == "<%SKIP_COMMENTS>":
                skipping_comments = True
            elif arg == "<%SINGLE_LINE>":
                single_line = True
            else:
                pstep = build_pstep(arg)
                srmline_index = srmfile.seek_line_index(pstep)

    if single_line:
        srmline = srmfile.get_unchecked_line_at(srmline_index)
        print(srmline)
    else:
        srmfile.display(srmline_index, skipping_comments)

def do_list_matches(srmfile, content_list=None):
    """Returns newline-separated list of lines matching path."""

    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        list_matches = srmfile.get_matching_lines(pstep)
        for line in list_matches:
            print(line)

# pylint: disable=unused-argument
def do_label(srmfile, content_list=None):
    """A do-nothing action that is used as a target for the 'goto'
    action."""
    pass
# pylint: enable=unused-argument

def do_goto(srmfile, content_list=None):
    """Goto to a target label if the SRMPath is True.

    The first parameter is the name of a "label" action
    to which execution will be shifted.

    The second, optional parameter, is an SRMPath expression
    that will be evaluated.  The absence of this parameter
    means the goto will be unconditional.

    An exception will be raised to signal the move if:
    1. The target label can be located, and
    2. The SRMPath expression is True."""

    if content_list and len(content_list) > 0:
        target = content_list[0]
        index = find_named_label_action(target)
        if index >= 0:
            if len(content_list) > 1:
                pstep = build_pstep(content_list[1])
                if srmfile.confirm_line_index(pstep):
                    raise SRMGotoTarget(index)
            else:
                raise SRMGotoTarget(index)

def do_goto_if_not(srmfile, content_list=None):
    """Goto a target label if the SRMPath is False.

    Syntax: goto-if-not <target-if-path-doesn't-exist> <path>

    Unlike 'goto', 'goto_if_not' requires two parameters:
    1. The target label
    2. The SRMPath that should not exist
    """
    if content_list and len(content_list) > 1:
        pstep = build_pstep(content_list[1])
        if not srmfile.confirm_line_index(pstep):
            target = content_list[0]
            index = find_named_label_action(target)
            if index >= 0:
                raise SRMGotoTarget(index)

def do_message(srmfile, content_list=None):
    """Display a message in output.  Used for demonstration purposes.

    The message command can be followed by any number of parameters
    terminated, as usual, by either -- or the end of the gensfw_srm
    parameter list.

    Optional message commands can be included in the message parameters.
    View the allowed message commands with gensfw_srm --show_message_cmds."""
    if content_list and len(content_list) > 0:
        for line in content_list:
            if line.startswith("<%") and line.endswith(">"):
                process_message_cmd(srmfile, line)
            else:
                print(line)

def do_hilite_message(srmfile, content_list=None):
    """Like 'message', but in a highlighted color."""

    set_ansi_message_color()
    do_message(srmfile, content_list)
    set_ansi_default_color()

def do_pause(srmfile, content_list=None):
    """Pause, with optional message, until the user presses ENTER."""

    if content_list and len(content_list) > 0:
        do_message(srmfile, content_list)

    input("Press ENTER to continue.")

def do_hilite_pause(srmfile, content_list=None):
    """Like 'pause' but in a highlighted color."""

    set_ansi_message_color()

    if content_list and len(content_list) > 0:
        do_message(srmfile, content_list)

    input("Press ENTER to continue.")
    set_ansi_default_color()

# pylint: disable=unused-argument
def do_dump_path(srmfile, content_list=None):
    """Display the parsed evaluation of the SRM path."""

    if content_list and len(content_list) > 0:
        pstep = build_pstep(content_list[0])
        pstep.dump()
# pylint: enable=unused-argument

def do_write_file(srmfile, content_list=None):
    """Write the output to the file named in the first parameter.

    In order to make the SRM path optional, the file path must
    be the first parameter following the action.  The following parameters
    must be either or both the <%SKIP_COMMENTS> token and an SRM path
    expression.

    if included, indicates the print starting point.  If there is no
    second parameter, the entire contents will be written out.

    The <%SKIP_COMMENTS> tag will be respected as with the display action."""

    if content_list and len(content_list) > 0:
        filename = content_list[0]
        skipping_comments = False
        index = 0

        for arg in content_list[1:]:
            if arg == "<%SKIP_COMMENTS>":
                skipping_comments = True
            else:
                pstep = build_pstep(arg)
                index = srmfile.seek_line_index(pstep)

        targetfile = open(filename, mode='w')
        srmfile.display(index, skipping_comments, targetfile)

def show_functions_by_prefix(prefix, with_docs=False):
    """Reads module to find functions that start with the prefix.
    The functions list is displayed with or without documentation
    according to the setting of parameter 'with_docs'."""
    thismod = sys.modules["__main__"]
    for elname in dir(thismod):
        obj = getattr(thismod, elname)
        if isinstance(obj, types.FunctionType):
            if elname.startswith(prefix):
                print(elname[len(prefix):])

                if with_docs:
                    set_ansi_message_color()
                    if obj.__doc__:
                        print(obj.__doc__)
                    else:
                        print("Documentation missing")
                    set_ansi_default_color()

                    print()
def show_usage():
    """Show command usage upon request or after a mistake."""
    msg = """
Usage:
    gensfw_srm (<filename> | "<%NEWFILE>") [ <action> <argument>... ] [ -- <action> <argument>... ]...
    gensfw_srm --help
    gensfw_srm --show_actions
    gensfw_srm --show_action_docs
    gensfw_srm --show_command_msgs
    gensfw_srm --show_command_msg_docs

    The first parameter is either the path to an SRM file, or the
    token "<%NEWFILE>".

    Following the file parameter, sets of parameters follow,  beginning
    with an "action", followed by 0 or more action parameters.  If more
    than one action is being defined, actions should be terminated by
    double-dashes (--).  The final action does not need does not need
    to be terminated

Options:
    --help, -h              This page
    --show_actions          Display the list of available actions.
    --show_action_docs      Display list of actions with explanations.
    --show_command_msgs     Display list of actions with explanations.
    --show_command_msg_docs Display list of actions with explanations.
"""
    print(msg)

def execute_arglist(srmfile, arglist):
    """Looks for suitable function to execute, executing it if found."""
    if len(arglist) > 0:
        mmod = sys.modules["__main__"]
        cur_action = "do_" + arglist[0].replace("-", "_")
        if cur_action in dir(mmod):
            cur_function = getattr(mmod, cur_action)
            if cur_function:
                cur_function(srmfile, arglist[1:])
            else:
                raise SRMUnknownAction(arglist[0])
        else:
            raise SRMUnknownAction(arglist[0])

def process_args(srmfile):
    """Iterate through command line arguments, collecting into groups
    delimited by '--' arguments.  Each group is submitted to function
    execute_arglist()."""

    arglist = []   # Buffer for passing to actions a subset of arguments
    startarg = 2   # Parameter index at which to start processing
                   # This may be reset with a "goto" action to restart
                   # the loop.

    # Skip argv[1], which is required to be an SRM filepath.
    while True:
        try:
            for arg in sys.argv[startarg:]:
                if arg == "--":
                    execute_arglist(srmfile, arglist)
                    arglist = []
                else:
                    arglist.append(arg)

            if len(arglist):
                execute_arglist(srmfile, arglist)

        except SRMGotoTarget as exception:
            startarg = int(exception.__str__())
            arglist = []
            continue

        # Break from "while True" after all arguments completed:
        break

def main():
    """Main program function."""
    srm_file = SRMFile()
    if len(sys.argv) < 2:
        show_usage()
        sys.exit(0)
    elif sys.argv[1].startswith("-"):
        option = sys.argv[1][1:]
        if option == "-help" or option == "h":
            show_usage()
        elif option == "-show_actions":
            show_functions_by_prefix("do_")
        elif option == "-show_action_docs":
            show_functions_by_prefix("do_", True)
        elif option == "-show_command_msgs":
            show_functions_by_prefix("msg_cmd_")
        elif option == "-show_command_msg_docs":
            show_functions_by_prefix("msg_cmd_", True)
            sys.exit(0)
    else:
        try:
            if sys.argv[1] != "<%NEWFILE>":
                srm_file.initialize(sys.argv[1])
            process_args(srm_file)
        except FileNotFoundError as exception:
            print("Failed to load '%s': file not found." % sys.argv[1])
        except SRMUnknownAction as exception:
            print("Attempted to call unknown action '%s'" % exception)
        except KeyboardInterrupt:
            print("Terminated with keyboard interruption.")
        except SRMFileBreak as exception:
            pass
        except PStepError as exception:
            print(exception)
        except SRMFilePathNotFound as exception:
            print("SRMPath '%s' not found." % exception)
        except SRMFileError as exception:
            print("The first parameter must be a path to a valid SRM file (%s)" % exception)

if __name__ == "__main__":
    main()
